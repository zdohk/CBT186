CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '
*  -----------------------------------------------------------------  *
*                                                                     *
*    Function:   To make an address space Cancelable or               *
*                Non-cancelable, Forcible or Non-forcible,            *
*                Swappable or Non-swappable.  Or BURN the             *
*                address space (version 1.3.6)                        *
*                                                                     *
*                This is determined by bit settings in the address    *
*                space's CSCB.                                        *
*                                                                     *
*  -----------------------------------------------------------------  *
*                                                                     *
*    Notes:                                                           *
*                                                                     *
*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *
*                                                                     *
*    CSCB        Cancelable, Non-cancelable, Forcible, Non-forcible   *
*    chain       are determined by bit settings in the address        *
*                space's CSCB, which is part of the CSCB chain.       *
*                                                                     *
*    Jobname     Each active address space has a CSCB in the chain.   *
*    and/or      You get to a particular address space by running     *
*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *
*    match       macro) looking for a match on jobname and/or ASID,   *
*                and preferably on both.                              *
*                                                                     *
*    DISPlay     There may be more than one address space for a       *
*    or          given job name, and more than one CSCB entry         *
*    "CSCB"      for a given ASID.  The CSCB or DISPlay option        *
*    option      of CNCLPG will run the entire CSCB chain and         *
*                it will show ALL the matches for the parameters      *
*                given.  To display the ENTIRE CSCB chain from start  *
*                to finish, use a dash ( - ) instead of the jobname.  *
*                                                                     *
*    Multiple    If only the jobname or the ASID number alone         *
*    jobs        are used to do an ACTION, then CNCLPG will stop      *
*    with the    at the FIRST CSCB which matches, when an ACTION is   *
*    same name   called for (but NOT for a DISPLAY).  That is why     *
*                it is better to run the DISPlay (or CSCB) function   *
*                of CNCLPG first, to display all the possible CSCB    *
*                entries that might match, before changing any        *
*                particular address space.  There might be more       *
*                than one address space with the same jobname or      *
*                ASID, and you want to change only the correct        *
*                one, NOT the wrong one.  So it is good practice      *
*                to display first, and then do a change to the        *
*                exact address space you want to affect, using        *
*                both the jobname and ASID(hhhh) parameters.          *
*                                                                     *
*           SWAPPABLE AND NON-SWAPPABLE:                              *
*                                                                     *
*    SWAP and    Setting an address space to be swappable or          *
*    NSWP need   non-swappable, is accomplished by executing          *
*    to run a    a SYSEVENT macro.  This has to execute in the        *
*    SYSEVENT    target address space, and it was done here by        *
*    macro in    scheduling an SRB to run in the target address       *
*    the         space, when it is different from the address         *
*    target      space running the program.                           *
*    address                                                          *
*    space                                                            *
*                                                                     *
*    -------------------------------------------------------------    *
*    BURN        BURN -  Kill the designated address space with a     *
*    (v 1.3.6)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *
*    -------------------------------------------------------------    *
*                                                                     *
*    Syntax:     TSO Command:  APF-authorized.                        *
*                                                                     *
*        CNCLPG |jobid ÝASID(hhhh)¨ |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *
*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *
*               |                   |CSCB or DISP                     *
*               |-  (displays the entire CSCB chain)                  *
*               |                   |RLxO or RLxF                     *
*               |?  (displays help)                                   *
*               |                   |BURN                             *
*                                                                     *
*    Date:       April 15, 2010                                       *
*                                                                     *
*    Latest Modification:   October 15, 2013                          *
*                                                                     *
*                                                                     *
*                                                                     *
*    Technical Detail:  PUTLINE interface for TSO Output.             *
*                                                                     *
*                                                                     *
*    Changes:  1.  SWAP, NSWP support dropped from this program.      *
*                   Version is 1.0.0                                  *
*                                                                     *
*              2.  Messages and DISP improved, to just show matching  *
*                   CSCB chain entries, instead of all of them.       *
*                   - will show the entire CSCB chain.                *
*                                                                     *
*              3.  SWAP, NSWP support put back in this program.       *
*                   Version is 1.1.0   (June 16, 2010)                *
*                   It now does your own address space.  The cross    *
*                   memory stuff was not put in yet, for other        *
*                   address spaces.                                   *
*                                                                     *
*              4.  RLxO or RLxF                                       *
*                                                                     *
*              5.  Burn an address space, if that is desired.         *
*                   (Oct 2013)  Version is 1.3.6.  Apply changes      *
*                   from between CNCLPG 1.2.0 and 1.2.5.              *
*                                                                     *
*                                                                     *
*   change   pgmr                   description                       *
*   -------  -----   ----------------------------------------------   *
*                                                                     *
*   1.2.0             Add SRB code to allow nonswappable in xmem      *
*                                                                     *
*   1.3.0             Add RLxO and RLxF support                       *
*   1.3.1             Fix RLxO and RLxF support                       *
*                     Fix bug when not "on" or "off" code entered     *
*                      for RLx* function                              *
*   1.3.6             Add BURN function to this version. Apply        *
*                      changes from CNCLPG 1.2.0 to 1.2.5.            *
*                                                                     *
*  -----------------------------------------------------------------  *
*  This macro lets you display hex values in a report.
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    STM   R15,R1,HEXSAVE           Save work registers.
         LA    R1,&FROM                 Load from address.
         LA    R0,&LEN                  Load length of hex number.
         LA    R15,&TO                  Load to address.
         BAL   R9,HEX                   BAL to routine.
         LM    R15,R1,HEXSAVE           Restore work registers.
         MEND
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
* --       End of Internal Macros......                            -- *
* ------------------------------------------------------------------- *
         SPACE 3
CNCLPG   CSECT
CNCLPG   AMODE 31
CNCLPG   RMODE ANY
         YREGS
AR7      EQU   7
AR8      EQU   8
AR9      EQU   9
AR10     EQU   10
         USING CNCLPG,R15          (Establish temporary base).
         B     BEGIN               Skip over eyecatcher.
EYEC0    DC    AL1(EYECL)          Exclusive length of header.
EYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'
         DC    C'     --------------------------------    '
         DC    C' VER 1.3.6   '
         DC    C'                   '
EYECL    EQU   *-EYEC
         DROP  R15                 (DROP TEMPORARY BASE).
BEGIN    STM   R14,R12,12(R13)     Save caller's registers
         LR    R6,R1               Preserve CPPL pointer.
         LR    R12,R15             Copy base.
         USING CNCLPG,R12,R11,R10  (Tell assembler).
         LA    R11,4095(,R12)      Load bases.
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LR    R14,R13             Copy caller's save area pointer.
         LA    R13,SAVE            Point to my save area.
         ST    R13,8(,R14)         Chain ...
         ST    R14,SAVE+4          ... Save areas.
         SPACE 1
INITCON  DS    0H                  Initialize some constants.
         MVI   FLAG1,X'00'
         MVI   FLAG2,X'00'
         MVI   FLAG3,X'00'
         MVI   ONSWIT,X'00'
         MVI   ERRASID,X'00'
         MVI   CANCINDC,X'00'
         MVI   OUTPUT-1,X'40'
         MVC   OUTPUT,OUTPUT-1
         MVI   NEWCHACT,X'00'
*        B     TEST                TEST CODE
MYASID   DS    0H                  Get my ASID
         L     R2,X'224'           Point to PSAAOLD (my ASCB)
         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)
         MVC   OWNASID(2),0(R2)    Save it for comparison later
         B     PRTITLE             Branch past constant
OWNASID  DS    H
PRTITLE  DS    0H                  Print program title.
         APUT  MESSAGET,L'MESSAGET
         APUT  MESSAGEU,L'MESSAGEU
CONT0    DS    0H                  Look at command's parameters.
         LTR   R6,R6               Any CPPL?
         BZ    EOJ8                No.  Get out.
         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)
         LTR   R1,R1               Any CMD buffer?
         BZ    EOJ8                Get out if none.
         LH    R3,0(,R1)           Load length.
         CH    R3,=H'4'            Anything?
         BNH   EOJ4                No. Get out.
         LR    R5,R3               Length of command + 4
         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.
         LH    R3,2(,R1)           Load offset.
         SR    R5,R3               Subtract offset from full length+4
         SH    R5,=H'4'            Correct for length of cmdbufr header
         BC    8,WMESS2            Zero, message to enter userid.
         BC    5,EOJ8              Less, or overflow, out.
PARM     DS    0H
         BAL   R9,GETIDS           Get parameters for the command.
         B     EOJ0
*
* --- Parms gotten at this point.                            -------- *
*
** ---------------------------------------------------------------- **
WMESS2   DS    0H                  Print help messages.
         BAL   R9,PRINTERR
         B     EOJ4
** ---------------------------------------------------------------- **
EOJ0     DS    0H                  End of job.
         APUT  RETURN0,L'RETURN0
         LA    R15,0               Set CC = 0.
         B     RETURN
EOJ4     DS    0H
         APUT  RETURN4,L'RETURN4
         LA    R15,4               Set CC = 4.
         B     RETURN
EOJ8     DS    0H
         APUT  RETURN8,L'RETURN8
         LA    R15,8               Set CC = 8.
         B     RETURN
RETURN   L     R13,SAVE+4
         L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BR    R14
** ---------------------------------------------------------------- **
NOTAUTH  DS    0H                  Command not APF authorized message.
         APUT  MESSAGNA,L'MESSAGNA
         B     EOJ4
** ---------------------------------------------------------------- **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*        Get the parameters for the command.                      *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   Notes:  The ASID(xxx) can be coded first, without a userid.   *
*           A dash can be coded first, to run the entire CSCB     *
*            chain and display all the jobnames in it, with       *
*            their associated ASIDs.  ? coded first gives HELP.   *
*           If you code the word CSCB or DISP(lay) after either   *
*            a jobname or an ASID(hhhh) then a display of the     *
*            matching CSCB chain entries will be displayed, and   *
*            no changes will be made.                             *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETIDS   DS    0H                  Get all parameters for the program.
         ST    R9,SAVER9A
         ST    R4,SAVER4C
         AR    R1,R3               Point ...
         LA    R1,4(,R1)           ... to char.
         LA    R6,8                Load reg for BCT loop.
         LR    R7,R1               Initialize pointer to first
         LA    R7,0(,R7)                character of the ID field.
         LA    R8,0                Initialize character count.
         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.
         LA    R4,JOBID            Point reg to beginng of JOBID field.
*
CUTIDLEN DS    0H                  Look at the JOBID field first.
*                                  (May contain ASID( or CSCB.)
*
         CLI   0(R7),X'40'         Is this character a blank?
         BE    NOMORCUT            Yes, we are at the end of the field.
         MVC   0(1,R4),0(R7)       Move only one character at a time.
         OC    JOBID(8),BLANKS     And uppercase the partial jobid.
*
*   Is this a run of the CSCB chain only?
* -- >  Test for CSCB  first  ---- below
         CLI   JOBID,C'-'          Did we code '-' first?
         BNE   CSCBHELP            No. Try if help asked for.
         B     CSCBRUN1            Yes. Run entire CSCB chain.
* - > Help
CSCBHELP DS    0H
         CLI   JOBID,C'?'          Help?
         BNE   NOCSCB              No. Skip this code.
         BAL   R9,PRINTERR         Yes. Print messages
         B     EOJ0                  and get out with code 0.
* - > Help
CSCBRUN1 DS    0H
         ST    R8,SAVER8A          Store count for display if needed.
         OI    FLAG2,X'40'         Mark that this is CSCB only run.
         BAL   R9,RUNCSCB          Do the run for CSCB chain.
         B     EOJ0                Out with normal return code.
NOCSCB   DS    0H
* -- >  Test for CSCB  first  ---- above
*
*   Was the ASCB(hhh) parameter coded without the jobid?
* -- >  Test for ASID( first  ---- below
         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?
         BNE   NOASIDF             No. Pass this code.
         OI    FLAG1,X'01'         Flag that ASID( ) was first.
         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag
         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.
         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     ASIDONLY            Bypass all the real jobname stuff.
* -- >  Test for ASID( first  ---- above
NOASIDF  DS    0H                  ASID( is not the first parameter.
         LA    R4,1(,R4)           Bump another character.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         CR    R8,R5               End of command buffer ?
         BNL   NOMORCUT            Yes. Get out now.
         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.
NOMORCUT DS    0H
         STC   R8,SAVCOUNT         Save length of Jobname
         L     R4,SAVER4C          Restore work register for use later.
         OC    JOBID(8),BLANKS     Uppercase the new Job Id.
         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.
*  -  Display the found JOBID - below
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search Jobname:'
         MVC   OUTPUT+17(8),JOBID
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL
*  -  Display the found JOBID - above
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     LOOKKEYW
*  Constants - below - ***
JOBID    DC    C'        '         STORE PARM USERID HERE
BLANKS   DC    C'        '         8 BLANKS
MESSAGET DC    C'CNCLPG 1.3.6 - Make a Job, STC or TSU Cancelable, etc.X
                (? for help)'
MESSAGEU DC   C'------ ----- - ---- - ---- --- -- --- ----------- ----'
MESSAGEL DC    C'----------------------------'
MESSAGEM DC    C'-----------------------------------------------'
MESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'
MESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, SWAP, CSCB or DIx
               SP.'
MESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'
MESSAG2D DC    C'   without changing them.'
MESSAG2E DC    C' When changing a job, we want to be accurate, '
MESSAG2F DC    C'  therefore you should use the DISPlay option first.'
MESSAG2Z DC    C'           SEE THE NOTES, BELOW.  '
MESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'
MESSAG2H DC    C' To see this help message, code ? for JOBNAME.'
MESSAG2I DC    C'Notes :     ** VERY IMPORTANT TO READ **'
MESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'
MESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '
MESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'
MESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '
MESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP will change the FIx
               RST'
MESSAG2O DC    C'  entry in the CSCB chain that matches, if MULTIPLE '
MESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'
MESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'
MESSAG2R DC    C'  which one you want to change specifically.'
MESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'
MESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'
MESSAGE3 DC    C'WE GOT HERE'
MESSAGE4 DC    C'TEST CHECK THIS'
MESSAGNG DC    C'Job was not done. SYSEVENT return code was     '
MESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'
MESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'
MESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'
MESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'
MESSAGFN DC    C'Function xxxx was called for.'
MESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'
RETURN0  DC    C'Return code is 0'
RETURN4  DC    C'Return code is 4'
RETURN4R DC    C'Return code is 4 from the SETRLD function'
RETURN8  DC    C'Return code is 8'
*                     ***  Places to save registers  ***  below
SAVER3A  DS    F
SAVER3B  DS    F
SAVER3C  DS    F
SAVER3D  DS    F
SAVER3E  DS    F
SAVER4A  DS    F
SAVER4B  DS    F
SAVER4C  DS    F
SAVER5A  DS    F
SAVER6A  DS    F
SAVER6B  DS    F
SAVER7A  DS    F
SAVER7B  DS    F
SAVER8A  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER9F  DS    F
SAVER9G  DS    F
SAVER9H  DS    F
SAVER9I  DS    F
SAVER9J  DS    F
SAVER9K  DS    F
SAVER9L  DS    F
SAVER9M  DS    F
SAVER9N  DS    F
SAVER9O  DS    F
SAVER9P  DS    F
*                     ***  Places to save registers  ***  above
SAVCOUNT DS    X
DUBLZERO DC    D'0'
FULLZERO DC    F'0'
CANCINDC DC    X'00'
CANCKEY0 DC    X'00'
NEWCHACT DC    X'00'
*  Constants - above - ***
LOOKKEYW DS    0H                  Look for additional keywords.
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         CR    R8,R5               End of command buffer?
         BNL   GETIDEND            Yes. Don't look any more.
         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.
         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.
ASIDONLY DS    0H                  Jump to here if ASID( coded first.
         OC    ASIDWKL(4),BLANKS   Uppercase work field.
         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?
         BE    DOASID              Yes. Process it.
         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?
         BE    DOCNCL              Yes. Process it.
         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?
         BE    DONCNC              Yes. Process it.
         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?
         BE    DOSWAP              Yes. Process it.
         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?
         BE    DONSWP              Yes. Process it.
         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?
         BE    DOFORC              Yes. Process it.
         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?
         BE    DONFRC              Yes. Process it.
         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   RL,ASIDWKL          Is RLxO or RLxF there?
         BE    DOACEE              Yes. Process it.
         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR
         BE    DOBURN              Yes. Process it.                 BUR
         B     LOOKKEYW            Go loop and look at next character.
ASIDWKL  DC    CL5' '              Second parameter work area.
*
ASIDC    DC    C'ASID('            Literals....
CNCLC    DC    C'CNCL'
NCNCC    DC    C'NCNC'
SWAPC    DC    C'SWAP'
NSWPC    DC    C'NSWP'
FORCC    DC    C'FORC'
NFRCC    DC    C'NFRC'
CSCBC    DC    C'CSCB'
DISPC    DC    C'DISP'
RL       DC    C'RL'
BURNC    DC    C'BURN'
*
DOASID   DS    0H                  Look for hex value of the ASID.
         OI    FLAG1,X'04'         Show that ASID( was coded.
         BAL   R9,GETASID          Go get the rest of the parameters.
         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for
*                                   a further parameter search.
         B     LOOKKEYW            Re-loop to look further for params.
*
DOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'01'         Show that CNCL was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
* ------------------------------------------------------------------- *
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CNCLC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'02'         Show that NCNC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NCNCC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOSWAP   DS    0H                  Not active yet.
         OI    FLAG2,X'04'
         MVC   MESSAGFN+9(4),SWAPC
         APUT  MESSAGFN,L'MESSAGFN
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         BAL   R9,KEY0SWNS
         BCT   R6,LOOKKEYW
         B     GETIDEND
* ------------------------------------------------------------------- *
DONSWP   DS    0H                  Not active yet.
         OI    FLAG2,X'08'
         MVC   MESSAGFN+9(4),NSWPC
         APUT  MESSAGFN,L'MESSAGFN
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         BAL   R9,KEY0SWNS
         BCT   R6,LOOKKEYW
         B     GETIDEND
* ------------------------------------------------------------------- *
DOFORC   DS    0H                  Handle FORC (forcible) keyword
         OI    FLAG2,X'10'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that FORC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),FORCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONFRC   DS    0H                  Handle NFRC (non-forcible) keyword
         OI    FLAG2,X'20'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that NFRC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NFRCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOCSCB   DS    0H
         OI    FLAG1,X'08'         Show CSCB keyword was coded.
         OI    FLAG2,X'40'         Show CSCB keyword was coded.
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CSCBC
         MVC   OUTPUT+23(9),=C'(DISPlay)'
         APUT  OUTPUT,35
         BAL   R9,RUNCSCB          Run the CSCB chain with print.
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOACEE   DS    0H                  Not active yet.
         MVC   MESSAGFN+9(4),ASIDWKL  Display entered
         APUT  MESSAGFN,L'MESSAGFN       function code.
         BAL   R9,SETRLD           Do RL function.
         TM    FLAG3,X'01'         Not "on" or "off"?
         BO    EOJ4                Report error.
         B     GETKEYNR            End normally.
* ------------------------------------------------------------------- *
GETIDEND DS    0H                  End of keyword processing.
         TM    FLAG2,X'FF'         Check if any real actions asked  BUR
         BM    GETKEYNR            Yes, some were.
         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.
         BAL   R9,PRINTERR
         B     EOJ4                   And end with code = 4.
GETKEYNR DS    0H                  Real actions WERE asked for.
         B     EOJ0                So end with normal return code.
         L     R9,SAVER9A
         BR    R9
** ---------------------------------------------------------------- **
SETRLD   DS    0H                  Do the RL function
         BAKR  R9,0                Save all registers on the stack
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match
         BAL   R9,GETASCB          Get the ASCB number
         LR    R9,R15              Point to ASCB
         L     R9,0(,R9)            Point to ASCB
         L     R10,ASCBASXB-ASCB(,R9)  Get ASXB
*--------------------------------------------------------------*
*                    Get bit setting                           *
*--------------------------------------------------------------*
         LA    R9,ACEETBL         Get ACEE table with bit settings
         USING ACEEFC,R9          Address our table
LOOKFUN  DS    0H                 Loop thru table
         CLI   FUNCT,255          Not found - end of table
         BE    ERROR              Error; get out
         CLC   FUNCT,ASIDWKL+2    Found function?
         BE    FOUFUNC            YES;
         LA    R9,3(,R9)          NEXT
         B     LOOKFUN            LOOK FOR FUNCTION AGAIN
FOUFUNC  DS    0H
         MODESET MODE=SUP,KEY=ZERO
         XR    R6,R6              Clear all Registers
         LH    R6,FOUNASID        Get Asid
         LA    R2,1               Give us AUTHORITY
         AXSET AX=(2)
         SSAR  R6                 Set SECONDARY ADDRESS SPACE
         SAC   512                AR MODE
         USING ACEE,R10           Address ACEE
         LAM   R9,R9,=F'0'
         LAM   AR7,AR7,=F'1'      SECONDARY ADDRESS SPACE
         LAM   AR10,AR10,=F'1'    SECONDARY ADDRESS SPACE
         L     R10,ASXBSENV-ASXB(,R10) Get ACEE
         LA    R7,ACEEFLG1        Get flag one
         XR    R8,R8              clear r8
         IC    R8,DISP            get disp
         LA    R7,0(R8,R7)        Point to byte
         CLI   ASIDWKL+3,C'F'     Turn  it off
         BE    OFF                YES;
         CLI   ASIDWKL+3,C'O'     Turn  it on
         BE    BITON              YES;
         OI    FLAG3,X'01'        ERROR has been marked
         B     RESET              Back to normal mode
BITON    DS    0H
         OC    0(1,R7),BITSET     set the bit
         B     RESET
OFF      DS    0H
         MVI   BYTE,255           all f's
         XC    BYTE,BITSET        Flip the bits
         NC    0(1,R7),BYTE       turn it off
RESET    DS    0H
         LH    R6,OWNASID         re-set sasid
         SSAR  R6
         SAC   0
         LAM   AR10,AR10,=F'0'    SECONDARY ADDRESS SPACE
         LAM   AR7,AR7,=F'0'      SECONDARY ADDRESS SPACE
         MODESET KEY=NZERO,MODE=PROB
         TM    FLAG3,X'01'        Not "on" or "off" command?
         BO    ERROR              Bad command. Show error. Code 4.
RETZERO  DS    0H
         XR    R15,R15            Clear return code
         B     RET
ERROR    DS    0H                 Don't do actions, display entered
         APUT  RETURN4R,L'RETURN4R
         LA    R15,4                function, and show help.
RET      DS    0H
         PR
** ---------------------------------------------------------------- **
ACEETBL  DC    C'S',X'80',X'00'     ACEESPEC
         DC    C'O',X'20',X'00'     ACEEOPER
         DC    C'U',X'10',X'00'     ACEEAUDT
         DC    C'P',X'02',X'00'     ACEEPRIV
         DC    C'K',X'01',X'00'     ACEERACF
         DC    C'A',X'80',X'01'     ACEEALTR
         DC    C'C',X'40',X'01'     ACEECNTL
         DC    C'D',X'20',X'01'     ACEEUPDT
         DC    C'R',X'10',X'01'     ACEEREAD
         DC    C'0',X'01',X'01'     ACEENONE
         DC    C'G',X'80',X'02'     ACEEGRPA
         DC    C'N',X'01',X'02'     ACEENPWR
         DC    X'FF'
*
ACEEFC   DSECT
FUNCT    DS   C                     FUNCTION
BITSET   DS   X                     Bit Setting
DISP     DS   X                     Displacement from ACEEFLG1
CNCLPG   CSECT                      Reestablish
BYTE     DS   X
** ---------------------------------------------------------------- **
HEX      DS    0H                  Display hex values.
         ST    R9,SAVER9B
         MVC   1(1,R15),0(R1)      Move byte.
         UNPK  0(3,R15),1(2,R15)   Unpack.
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         Increment output pointer.
         LA    R1,1(,R1)           Increment input pointer.
         BCT   R0,HEX              Decrement length, then loop.
         MVI   0(R15),C' '         Blank the trailing byte.
         L     R9,SAVER9B
         BR    R9                  Return to caller.
HEXTAB   DC    C'0123456789ABCDEF' Translate table.
** ---------------------------------------------------------------- **
GETASID  DS    0H                  Get hex ASID for 2 bytes.
         ST    R9,SAVER9C          Save registers.
         STM   R1,R6,SAVERGS1
         LA    R6,4                Load BCT register.
         LA    R4,ASIDWK           Point to ASID work area.
         TM    FLAG1,X'02'         Ask if Job name was coded.
         BZ    GETAFL01            Wasn't. Have to adjust pointers.
         LA    R7,5(,R7)           Bump command buffer pointer.
         LA    R8,5(,R8)           Bump character counter.
GETAFL01 DS    0H
GETASIDL DS    0H                  Loop to get hex ASID for 4 display
*                                    bytes to convert to 2 hex bytes.
         CLI   0(R7),C')'          Have we reached close parenthesis?
         BE    GETASIDG            Yes, assume we've got it.
         CLI   0(R7),C' '          Have we hit a blank?
         BE    GETASIDG            Yes, assume we've got it.
         MVC   0(1,R4),0(R7)       Otherwise move one character over.
         LA    R4,1(,R4)           Bump one ASIDWK character (target)
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         BCT   R6,GETASIDL         Loop for 4 characters.
         B     GETASIDG            We don't look for more than 4.
GETASIDG DS    0H
*        APUT  ASIDWK,4
         LA    R4,ASIDWK           Point register at workarea again.
         LA    R1,4                Maximum of 4 characters.
GETASIDA DS    0H
         CLI   3(R4),X'40'         Is last character a blank (<4 total)
         BNE   GETASIDM            No. We're finished sliding.
         BCTR  R4,0                Slide the pointer one place back.
         BCT   R1,GETASIDA         Do it no more than 4 times.
GETASIDM DS    0H
         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one
*                                     is not blank.
         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters
         MVC   ASIDWKS(4),ASIDMV        in two places.
         MVC   OUTPUT,OUTPUT-1       Clear output line.
         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.
         APUT  OUTPUT,40             And put out the message.
         TR    ASIDMV(4),ASIDVAL     Translate display format message
*                                      into format X'0h0h0h0h'.
*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.
*        HEX   OUTPUT,4,ASIDMV
*        APUT  OUTPUT,10
         BAL   R9,VALIDTR            Validity check the hex number.
         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes
         HEX   OUTPUT+21,2,ASIDBIN
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.
*
GETASIDE DS    0H                    End of routine.
         LM    R1,R6,SAVERGS1        Restore registers
         L     R9,SAVER9C               and
         BR    R9                          exit.
** ----------------------------------------------------------------
*
*   GETASCB return ASCB give the asid of address space
*
*
*
*  Input:
*      FOUNASID = ASID
*  OutPut:
*      r15 = 0    Error
*      r15 = ASCB
** ----------------------------------------------------------------
GETASCB  DS    0H
         ST    R9,SAVER9O            Save Register
         L     R15,CVTPTR            R15 -> cvt
         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt
         USING ASVT,R15
         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher
         BNE   NOASCB
         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot
         LH    R0,FOUNASID           Get asid in question
         BCTR  R0,0                  Down By 1
         SLL   R0,2                  Multiply by 4
         AR    R15,R0                Point to ASCB
         BR    R9
NOASCB   DS    0H
         XR    R15,R15               Clear r15
         L     R9,SAVER9O            Restore Register
         BR    R9
ASIDWKB  DC    CL4'    '
ASIDWK   DC    CL4'    '
ASIDWKF  DC    CL4' '
ASIDMV   DC    CL4'    '
ASIDMVF  DC    CL4' '
ASIDBIN  DS    0XL2
ASIDGET  DC    XL4'00000000'

SAVERGS1 DS    6F
*                   Translate table to validity check ASID.
*                     Convert display values to X'0h'
*                     (where h is the hex value).
ASIDVAL  DS    0D
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00010203040506070809CCCCCCCCCCCC'
FILLER1  DS    CL24
ASIDMSG  DC    CL21'ASID parm entered  : '
ASIDWKSV DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
FINDCSCB DS    0H                  Find CSCB entry to change or report.
         ST    R9,SAVER9D          Save registers.
         ST    R3,SAVER3A
FINDCSST DS    0H                  Get the first CSCB.
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         USING CHAIN,R3            Tell assembler.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
FINDCSLP DS    0H                  Loop through the CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
* ------------------------------------------------------------------- *
* We first try to match a JOBID if coded, to the job id in this CSCB. *
* If equal, we see if an ASID has been coded, and both have to match. *
* Otherwise, with no match, we go to the end of the CSCB chain.       *
* ------------------------------------------------------------------- *
FINDCSMY DS    0H                  Find the CSCB that I want.
         TM    FLAG1,X'04'         Was ASID( coded at all?
         BZ    FINDCSJB            No. Just find a JOBID match.
         TM    FLAG1,X'01'         Is the JOB id missing?
         BO    FINDCSAS            Yes, just look for an ASID match.
         TM    FLAG1,X'02'         Was JOB id coded?
         BO    FINDCSJB            Yes. Look for it.
         ICM   R3,15,0(R3)         Go to next CSCB.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
         B     FINDCSLP            Look at next CSCB entry in table.
FINDCSJB DS    0H                  Check for JOBID match in this CSCB.
         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.
         BE    FINDCSIA            Equal, check if ASID is there.
         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.
         BZ    FINDCSEC            Zero, end of the CSCB chain.
         B     FINDCSLP            Not zero, look at the next entry.
FINDCSIA DS    0H
         TM    FLAG1,X'04'         Was ASID( coded?
         BZ    FINDCSFD            No. Found it on just a job match.
*                                   So this is the first job that
*                                   matched, if there are multiple
*                                   jobs with the same name.
FINDCSAS DS    0H                  Check the ASID in the CSCB.
         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.
         BE    FINDCSFD            I guess we found it.
         ICM   R3,15,0(R3)         Go to the next CSCB.
         BZ    FINDCSEC            Zero marks the end of the CSCB chain
         B     FINDCSLP            Not zero. Look at the next entry.
FINDCSFD DS    0H                  Our CSCB has been found.
         ST    R3,FOUNCSCB         Save found CSCB address.
         MVC   FOUNACTF,CHACT      Save
         MVC   FOUNJOBI,CHKEY        CSCB
         MVC   FOUNPROC,CHCLS          info.
         MVC   FOUNASID,CHASID
         BAL   R9,PRNTCSCB         Print info from the current CSCB.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.
         B     FINDCSEN            Go to end of routine.
         DROP  R3
FINDCSEC DS    0H                  Came to end of CSCB chain.
         APUT  MESSAGEN,L'MESSAGEN   Then put out a message
         B     EOJ4                  And end with code 4.
FINDCSEN DS    0H
         L     R3,SAVER3A
         L     R9,SAVER9D
         BR    R9
*            Constants associated with this routine.    -    below
FOUNACTF DC    X'00'
FOUNCSCB DS    F                   FOUND CSCB ADDRESS
FOUNJOBI DC    CL8' '
FOUNPROC DC    CL8' '
FOUNASID DC    H'0'
CSCBACTF DC    X'00'
CSCBJOBI DC    CL8' '
CSCBPROC DC    CL8' '
CSCBASID DC    H'0'
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
VALIDTR  DS    0H                  Validate hex characters coded.
         ST    R9,SAVER9E          Save
         STM   R4,R6,SAVEWRK          registers.
         LA    R4,ASIDMV           Point to translated display chars.
         LA    R6,ASIDWKS          Point to chars with error signs.
         LA    R5,4                BCT register - only 4 times.
VALIDTRS DS    0H
         CLI   0(R4),X'CC'         Is this an invalid character?
         BE    VALIDTRR            Yes. Substitute a ? for message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char for error message.
         BCT   R5,VALIDTRS         Loop to test validity of this char.
         TM    ERRASID,X'01'       After 4 chars, any errors found?
         BO    VALIDERR            Yes. Write messages.
         B     VALIDTRE            No. Get out of routine.
VALIDTRR DS    0H                  Come here if invalid char found.
         OI    ERRASID,X'01'       Flag that at least one was found.
         MVI   0(R6),C'?'          Substitute a ? for it in message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char in error message.
         BCT   R5,VALIDTRS         Check that character for validity.
VALIDERR DS    0H                  Error messages if char is invalid.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(37),ASIDBADM
         APUT  OUTPUT,45
*        MVC   OUTPUT,OUTPUT-1
*        MVC   OUTPUT(51),MSGBADPR
*        APUT  OUTPUT,52
         B     EOJ4                Get out with code 4.
VALIDTRE DS    0H
         L     R4,SAVER4B          Restore regs used in this routine.
         LM    R4,R6,SAVEWRK
         BR    R9
*            Constants associated with this routine.    -    below
ERRASID  DC    X'00'
SAVEWRK  DS    3F
MSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'
ASIDBADM DC    CL33'Bad Characters marked with a ?:  '
ASIDWKS  DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address
PRNTCSCB DS    0H                  Print a CSCB entry.
         ST    R9,SAVER9F          Save BAL register.
         ST    R3,SAVECSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from current CSCB
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         TM    FLAG2,X'80'                Is this a BURN action?    BUR
         BO    PRNTFINI                   Yes. Abridge the messages BUR
         TM    FLAG2,X'40'
         BO    PRNTCSC1
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Previous CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         B     PRNTCSC2
PRNTCSC1 DS    0H
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Current  CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
PRNTCSC2 DS    0H
         DROP  R3
PRNTFINI DS    0H
         L     R3,SAVECSCB         Restore register to what it was.
         L     R9,SAVER9F          Restore BAL register and
*                                     branch back to caller.
         BR    R9
SAVECSCB DS    F                   Saved address of found CSCB.
** ---------------------------------------------------------------- **
RUNCSCB  DS    0H                  Run through the CSCB chain.
         ST    R9,SAVER9G
         ST    R3,SAVER3C
         ST    R7,SAVER7A
RUNCSCBT DS    0H
         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.
         BZ    RUNCSCBE            Not coded, get out.
*                                  Display this is a CSCB chain run.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'
         APUT  OUTPUT,45
         APUT  MESSAGEL,L'MESSAGEL   Print underline.
*                                  Find the CSCB chain:
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         BZ    RUNCSCBE            If zero, end of CSCB chain.
*                                  Otherwise points to next CSCB in
*                                    the table.
         USING CHAIN,R3
RUNCSCBD DS    0H                  Loop through CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
*  Test
*        MVC   OUTPUT,OUTPUT-1
*        HEX   OUTPUT,2,CHASID
*        HEX   OUTPUT+6,2,ASIDBIN
*        MVI   OUTPUT+15,C'i'
*        APUT  OUTPUT,25
*  Test
* -- Limit print of entries to Jobname or ASID only ----  below
         CLI   JOBID,C'-'          Are we printing the whole CSCB?
         BE    RUNCSCBY            Yes.
         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?
         BNE   RUNCSCB2            No. Just check for Jobname.
RUNCSCB1 DS    0H                  Check for Jobname match.
         XR    R7,R7               Clear work register.
         IC    R7,SAVCOUNT         Insert saved length of Jobid.
         BCTR  R7,0                Decrement for execute.
         EX    R7,RUNCSCOM         Do the compare for proper length.
*        BNE   RUNCSCBS            Not equal, don't print result.
         BE    RUNCSCBP            Equal, print this CSCB entry.
RUNCSCB2 DS    0H                  Check if ASID was coded.
         CLC   ASIDBIN,CHASID      ASID match?
         BNE   RUNCSCBS            No. Skip print of CSCB entry.
RUNCSCBY DS    0H
* -- Limit print of entries to Jobname or ASID only ----  above
RUNCSCBP DS    0H                  Print this entry....
         BAL   R9,PRNTCSCB         Print of current CSCB information.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.
RUNCSCBS DS    0H                  If skipping an entry print, go here.
         ICM   R3,15,0(R3)         Go to next CSCB entry in table.
         BZ    RUNCSCBE            If it is zero, end of CSCB chain.
         B     RUNCSCBD            Not zero, loop to next entry and
*                                    print it.
RUNCSCBE DS    0H                  End of routine.
         L     R3,SAVER3C          Restore
         L     R7,SAVER7A
         L     R9,SAVER9G             registers and
         BR    R9                        go back to caller.
RUNCSCOM CLC   JOBID(*-*),CHKEY   Executed
         DROP  R3
** ---------------------------------------------------------------- **
KEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.
         ST    R9,SAVER9H
         ST    R4,SAVER4A
*
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
*
* -- >    ***    Do as little as possible under Key 0.    ***
KEYPRLIM DS    0H
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    SWITOFF             No. Try AND-ing?
         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.
         B     SWITON              All done pre-processing.
SWITOFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0BYPS            No. Don't do anything else.
         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.
         MVC   CANCKEY0,CANCINDC   And move them to staging area.
SWITON   DS    0H
         USING CHAIN,R3
         L     R3,FOUNCSCB         Save address of "found CSCB".
*
* -- >                             We're authorized. Go Key 0.
         MODESET KEY=ZERO
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    KEY0OFF             No. Try AND-ing.
         OC    CHACT(1),CANCKEY0   Do the OR.
         B     KEY0END             Out of Key 0.
KEY0OFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0END             No. Get out altogether.
         NC    CHACT(1),CANCKEY0   Do the AND.
KEY0END  DS    0H                  Out of Key 0.
         MODESET KEY=NZERO
*
KEY0BYPS DS    0H                  Key 0 bypass - branch to here.
         DROP  R3
         L     R4,SAVER4A
         L     R9,SAVER9H
         BR    R9
** ---------------------------------------------------------------- **
PRNWCSCB DS    0H                  Print the changed CSCB entry.
         ST    R9,SAVER9I          Save BAL register.
         ST    R3,SAVER3D
         L     R3,FOUNCSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from changed CSCB.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Modified CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         APUT  MESSAGEL,L'MESSAGEL
         DROP  R3
         L     R3,SAVER3D          Restore register to what it was.
         L     R9,SAVER9I          Restore BAL register and
         BR    R9                     branch back to caller.
** ---------------------------------------------------------------- **
FORCHACT DS    0H                  Format the CHACT Flags
         ST    R9,SAVER9J          Save
         ST    R3,SAVER3E             registers.
         USING CHAIN,R3
FORCANC0 DS    0H                  Show cancelable or not.
         TM    CHACT,CHCL          Is job cancelable?
         BO    FORCANC1            Yes, show cancelable.
         BZ    FORCANC2            No. Show non-cancelable.
         B     FORFORC0            Fall through, try forceable.
FORCANC1 DS    0H
         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.
         B     FORCANCP
FORCANC2 DS    0H
         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.
FORCANCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORFORC0 DS    0H                  Show forceable or not.
         TM    CHACT,CHAFORCE      Is job forceable?
         BO    FORFORC1            Yes, show forceable.
         BZ    FORFORC2            No. Show non-forceable.
FORFORC1 DS    0H
         MVC   MESSTXT,MESSFOR     Tell em job is forceable.
         B     FORFORCP
FORFORC2 DS    0H
         MVC   MESSTXT,MESSNFR     Tell em job is non-forceable.
FORFORCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORCHEND DS    0H
         DROP  R3
         L     R3,SAVER3E          Restore
         L     R9,SAVER9J             registers.
         BR    R9
*            Constants associated with this routine.    -    below
MESSCAN  DC    CL14'Cancelable    '
MESSNCN  DC    CL14'Non-Cancelable'
MESSFOR  DC    CL14'Forcible      '
MESSNFR  DC    CL14'Non-Forcible  '
FORMTMSG DS    0CL28
MESS000  DC    CL14'Job Status:   '
MESSTXT  DC    CL14'              '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
PRINTERR DS    0H                    Print help messages.
         ST    R9,SAVER9K            Save BAL register.
         APUT  MESSAG2A,L'MESSAG2A
         APUT  MESSAG2B,L'MESSAG2B
         APUT  MESSAG2C,L'MESSAG2C
         APUT  MESSAG2D,L'MESSAG2D
         APUT  MESSAG2E,L'MESSAG2E
         APUT  MESSAG2F,L'MESSAG2F
         APUT  MESSAG2Z,L'MESSAG2Z
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2G,L'MESSAG2G
         APUT  MESSAG2H,L'MESSAG2H
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2I,L'MESSAG2I
         APUT  MESSAG2J,L'MESSAG2J
         APUT  MESSAG2K,L'MESSAG2K
         APUT  MESSAG2L,L'MESSAG2L
         APUT  MESSAG2M,L'MESSAG2M
         APUT  MESSAG2N,L'MESSAG2N
         APUT  MESSAG2O,L'MESSAG2O
         APUT  MESSAG2P,L'MESSAG2P
         APUT  MESSAG2Q,L'MESSAG2Q
         APUT  MESSAG2R,L'MESSAG2R
         APUT  MESSAG2S,L'MESSAG2S
         APUT  MESSAG2T,L'MESSAG2T
         APUT  MESSAGEM,L'MESSAGEM
         L     R9,SAVER9K            Restore BAL register.
         BR    R9
** ---------------------------------------------------------------- **
DOBURN   DS    0H                        BURN process.              BUR
*                                        Print the action code.     BUR
         OI    FLAG2,X'80'               Mark as a BURN.            BUR
         MVC   OUTPUT,OUTPUT-1                                      BUR
         MVC   OUTPUT(15),=C'Action code   :'                       BUR
         MVC   OUTPUT+17(4),BURNC                                   BUR
         APUT  OUTPUT,25                                            BUR
* -- >  Test if this command is being run APF Authorized - below    BUR
         STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR
         XR    R15,R15                authorized.                   BUR
         TESTAUTH FCTN=1           Are we authorized?               BUR
         LTR   R15,R15             Test the return code.            BUR
         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR
         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR
* -- >  Test if this command is being run APF Authorized - above    BUR
         BAL   R9,FINDCSCB               Get the Address Space.     BUR
         MODESET KEY=ZERO,MODE=SUP                                  BUR
         ST    R7,SAVER7B                Store work register        BUR
         LH    R7,CSCBASID               Set ASID                   BUR
         ST    R13,SAVER13A              Save R13                   BUR
         LA    R13,RTMSAVE               RTM save area              BUR
         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR
         L     R13,SAVER13A              Restore R13                BUR
         L     R7,SAVER7B                Restore work register      BUR
         MODESET KEY=NZERO,MODE=PROB                                BUR
         MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        BUR
         B     GETIDEND            After enough looks, end.         BUR
RTMSAVE  DS    CL72                Work area for RTM                BUR
SAVER13A DS    F                   Place to save R13                BUR
** ---------------------------------------------------------------- **
KEY0SWNS DS    0H                    Key 0 for SWAP or NSWP
         ST    R9,SAVER9L            Save BAL register.
         ST    R6,SAVER6A
KEY0TSTA DS    0H
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
         TM    FLAG2,X'04'         Make ASID swappable?
         BO    KEY0SWAP            Yes. Do it.
         TM    FLAG2,X'08'         Make ASID non-swappable?
         BO    KEY0NSWP            Yes. Do it.
         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.
*
KEY0NSWP DS    0H                    Make address space non-swappable.

         CLC   OWNASID,FOUNASID      Target asid different from ours?
         BE    KEY0DNSW              No. Just do SYSEVENT.
         MVC   FUNC,=CL8'DONTSWAP'   Set nswapping function
         BAL   R9,BUILDSRB           Build SRB block
*
* ISSUE SUCCESSFUL MESSAGE
*
         MVC   MESSAGNS+4(8),FOUNJOBI
         HEX   MESSAGNS+22,2,FOUNASID
         APUT  MESSAGNS,L'MESSAGNS
         L     R6,SAVER6A            Restore Register
         L     R9,SAVER9L            Restore BAL register.
         BR    R9                    go back
TEMPSAVE DS    4F                    save area
* - cross address space stuff - above
KEY0DNSW DS    0H
         MODESET MODE=SUP,KEY=ZERO
KEY0SYSD DS    0H
         LH    R6,FOUNASID
         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC
*        STATUS SET,MC,STEP                  EXCLUSIVE TASK
*        LA    R1,1                          LOAD NEW AUTH. INDEX
*        AXSET AX=(1)                        SET NEW AUTH. INDEX
*        ST    R0,OLDAX                      SAVE OLD AUTH. INDEX
*        LH    R1,FOUNASID                   LOAD JES2 ASID.
*        SSAR  R1                            SET SPACE SECONDARY JES2.
*        ST    R1,SYSEVCOD
*        LTR   R1,R1
*        BNZ   KEY0NODO
*        STATUS RESET,MC,STEP
KEY0NNRM DS    0H
         MODESET MODE=PROB,KEY=NZERO
         MVC   MESSAGNS+4(8),FOUNJOBI
         HEX   MESSAGNS+22,2,FOUNASID
         APUT  MESSAGNS,L'MESSAGNS
         B     KEY0EXIT
KEY0SWAP DS    0H                    Make address space swappable.
         CLC   OWNASID,FOUNASID      Target asid different from ours?
         BE    KEY0DSWP              No. Just do SYSEVENT.
         MVC   FUNC,=CL8'OKSWAP'     Set function
         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS
*
*  issue successful message
*
         MVC   MESSAGSW+4(8),FOUNJOBI
         HEX   MESSAGSW+22,2,FOUNASID
         APUT  MESSAGSW,L'MESSAGSW
         L     R6,SAVER6A            Restore Registers
         L     R9,SAVER9L            Restore BAL register.
         BR    R9
* - cross address space stuff - below
* - cross address space stuff - above
KEY0DSWP DS    0H
         LH    R6,FOUNASID
         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC
*        STATUS RESET,MC,STEP
*        ST    R1,SYSEVCOD
*        LTR   R1,R1
*        BNZ   KEY0NODO
KEY0SNRM DS    0H
         MODESET MODE=PROB,KEY=NZERO
         MVC   MESSAGSW+4(8),FOUNJOBI
         HEX   MESSAGSW+22,2,FOUNASID
         APUT  MESSAGSW,L'MESSAGSW
         B     KEY0EXIT
KEY0NODO DS    0H
         MODESET MODE=PROB,KEY=NZERO
         HEX   MESSAGNG+43,1,SYSEVCOD+3
         APUT  MESSAGNG,L'MESSAGNG
KEY0EXIT DS    0H
         L     R6,SAVER6A
         L     R9,SAVER9L            Restore BAL register.
         BR    R9
*--------------------------------------------------------------*
*                                                              *
*        build srb control block and accompanying code         *
*--------------------------------------------------------------*
BUILDSRB DS    0H
         STM   R6,R9,TEMPSAVE        Save Registers
         BAL   R9,GETASCB            Find ASCB for this asid
         LR    R9,R15                Hold ASCB
         L     R9,0(,R9)             Point to ASCB
         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state
*
CSA_LEN  EQU  SRBSIZE+84             Csa SRBLOCK AND PARAMTERS
*
*---------------------------------------------------------------*
*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *
*---------------------------------------------------------------*
         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA
         LR    R6,R1                 Point r2 to srb control block
         USING SRB,R6                Address SRB
         XC    SRB(SRBSIZE),SRB      Clear out srb
         ST    R9,SRBASCB            Save ASCB
         LA    R8,SRBSIZE(,R6)       R8 -> paramlist
*       Get CSA paramter list                                   *
         ST    R8,SRBPARM            Store paramter list address
         LA    R7,72(,R8)            Point to ECB
         XC    0(4,R7),0(R7)         Clear ECB Address
         LA    R7,4(,R7)             Point to ASCb
         MVC   0(4,R7),X'224'        Move "HOME" PSAAOLD address sp
         LA    R7,4(,R7)             bump to next param
         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function
         BE    NONSWAP               yes; branch if so
         MVC   0(4,R7),=C'OKSW'      otherwise swappable
         B     SETEPA                set srb program entry point
NONSWAP  DS    0H
         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7
*---------------------------------------------------------------*
*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *
*---------------------------------------------------------------*
SETEPA   DS    0H
         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA
         ST    R1,SRBEPA             set entry point
         LR    R14,R1                Hold that thought
         LA    R15,SWAPLEN           Get Length
         LR    R1,R15
         LA    R0,SWAPXMEM           Point to SRB routine
         MVCL  R14,R0                Move routine
*
         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM
*
         LA    R7,72(,R8)            Point to ECB
*
         WAIT  ECB=(R7)
*
         L     R9,SRBEPA             Get Entry Point Address
*
         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241
*
         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227
*
         MODESET KEY=NZERO,MODE=PROB
*
         LM    R6,R9,TEMPSAVE        Save Registers
         BR    R9                    Return
SYSEVCOD DC    F'0'                  SYSEVENT Return Code
OLDAX    DS    F
WAREA    DS    D                     Work area
WAREB    DS    D                     Work area
** ---------------------------------------------------------------- **
** --         C  O  N  S  T  A  N  T  S                          -- **
** ---------------------------------------------------------------- **
MESSAGNA DC    C'Command was not invoked APF authorized.'
MESSAGEN DC    C'End of CSCB chain was reached.'
MESSAGEY DC    C'No valid keyword was coded.'
FLAG1    DC    X'00'
*              X'01'               ASID ONLY - NO JOBNAME
*              X'02'               JOBNAME IS PRESENT.
*              X'04'               ASID( WAS PRESENT IN PARMS.
*              X'08'               CSCB CHAIN DISPLAY ONLY.
FLAG2    DC    X'00'
*              X'01'               CNCL WAS CODED
*              X'02'               NCNC WAS CODED
*              X'04'               SWAP WAS CODED
*              X'08'               NSWP WAS CODED
*              X'10'               FORC WAS CODED
*              X'20'               CSCB WAS CODED
*              X'80'               BURN WAS CODED                   BUR
FLAG3    DC    X'00'
ONSWIT   DC    X'00'
*              X'01'               TURN BIT ON
*              X'02'               TURN BIT OFF
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
SAVE     DS    9D                  Program Save Area
SAVE14T1 DS    2D                  Save "system-used" registers.
         DC    C' '                Blank before OUTPUT line.
OUTPUT   DC    CL80'  '            Variable output line.
FUNC     DS    CL8                 Swapppinmg function
         LTORG
*-----------------------------------------------------------------*
*                         SRB CODE                                *
*-----------------------------------------------------------------*
SWAPXMEM DS    0D
         DROP  R12,R11,R10
         BASR  R5,0
         USING *,R5                  Entry Point
         LR    R10,R14               SAVE RETURN ADDRESS
         LR    R13,R1
*
         LA    R9,72(,R13)          Point to ECB Address
         LA    R8,76(,R13)          Point to ASCB Address
         L     R8,0(,R8)
         L     R7,80(,R13)          Get code
*
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE
*
         C      R7,=C'OKSW'        OKSWAP
         BE     SETSWAP
*
         SYSEVENT DONTSWAP,ENTRY=BRANCH
*
         B      UNLOCK
*
SETSWAP  DS     0H
         SYSEVENT OKSWAP,ENTRY=BRANCH
*
UNLOCK   DS     0H
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE
*
*
         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH
*
GOBACK   LR    R14,R10               Return Address
         BR    R14                   Return
         LTORG
SWAPRTM  DS    0D
SWAPLEN  EQU   *-SWAPXMEM
** ---------------------------------------------------------------- **
         IHAACEE
         SPACE
         TITLE '- MAPPING MACROS.'
         CVT   DSECT=YES           Map the CVT.
         IEECHAIN                  Map the CSCB control block.
         IHASRB
         IHAASVT
         IHAASCB
         IHAASXB
         IRAOUCB
         IHAPSA   DSECT=YES,LIST=YES                           HD APR88
         IHAFRRS
         EJECT                                                 HD APR88
         IKJEFLWA
         END   CNCLPG
** ---------------------------------------------------------------- **
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUEMNTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         IHAPSA   DSECT=YES,LIST=YES                           HD APR88
         EJECT
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   14,12,12(13)       SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES            RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    1,8(13)            OUR SAVE AREA POINTER
         ST    13,4(1)            POINTER TO CALLERS SAVE AREA
         LR    13,1               @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(R13)         POINT TO CALLERS RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 ASSUME BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 ASSUME BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(RML)               MESSAGE LENGTH
         STH   R15,PUTLEN                 PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA
         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    2,R13                    @OUR SAVE AREA
         LR    3,R15                    SAVE RETURN CODE
         L     R13,4(R13)               @CALLERS SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,3                    RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END EPUTL
