CNCLPG   TITLE 'Make address space cancelable, non-swappable, etc. '
*  -----------------------------------------------------------------  *
*                                                                     *
*    Function:   To make an address space Cancelable or               *
*                Non-Cancelable, Forcible or Non-Forcible,            *
*                Swappable or Non-Swappable.  Or BURN the             *
*                address space (version 1.4.0).  KILL the             *
*                address space is same as BURN, but first             *
*                the non-MEMTERM bits in the ASCB are                 *
*                turned off (version 1.4.1).                          *
*                                                                     *
*                If the address space is non-MEMTERM-able,            *
*                and you try to BURN it, an error message             *
*                is issued, and nothing occurs.  But if you           *
*                try and KILL it, the non-MEMTERM bits are            *
*                turned off, and the address space is whacked.        *
*                The message will tell you so.                        *
*                                                                     *
*    Authority:  You need PSCB OPER authority to run this             *
*                command.  To do BURN, KILL, NMEM, and MEMT           *
*                functions, you ALSO need PSCB ACCOUNT authority.     *
*                Any function controlled by the KILLFLAG, needs       *
*                PSCB ACCOUNT authority.                              *
*                Enhanced:  (Version 1.4.3)                           *
*                                                                     *
*  -----------------------------------------------------------------  *
*                                                                     *
*    Notes:                                                           *
*                                                                     *
*           CANCELABLE, NON-CANCELABLE, FORCIBLE, NON-FORCIBLE:       *
*                                                                     *
*    CSCB        Cancelable, Non-Cancelable, Forcible, Non-Forcible   *
*    chain       are determined by bit settings in the address        *
*                space's CSCB, which is part of the CSCB chain.       *
*                                                                     *
*    Jobname     Each active address space has a CSCB in the chain.   *
*    and/or      You get to a particular address space by running     *
*    ASID        the entire CSCB chain (mapped by the IEECHAIN        *
*    match       macro) looking for a match on jobname and/or ASID,   *
*                and preferably on both.                              *
*                                                                     *
*    DISPlay     There may be more than one address space for a       *
*    or          given job name, and more than one CSCB entry         *
*    "CSCB"      for a given ASID.  The CSCB or DISPlay option        *
*    option      of CNCLPG will run the entire CSCB chain and         *
*                it will show ALL the matches for the parameters      *
*                given.  To display the ENTIRE CSCB chain from start  *
*                to finish, use a dash ( - ) instead of the jobname.  *
*                                                                     *
*    Multiple    If only the jobname or the ASID number alone         *
*    jobs        are used to do an ACTION, then CNCLPG will stop      *
*    with the    at the FIRST CSCB which matches, when an ACTION is   *
*    same name   called for (but NOT for a DISPLAY).  That is why     *
*                it is better to run the DISPlay (or CSCB) function   *
*                of CNCLPG first, to display all the possible CSCB    *
*                entries that might match, before changing any        *
*                particular address space.  There might be more       *
*                than one address space with the same jobname or      *
*                ASID, and you want to change only the correct        *
*                one, NOT the wrong one.  So it is good practice      *
*                to display first, and then do a change to the        *
*                exact address space you want to affect, using        *
*                BOTH the jobname and ASID(hhhh) parameters.          *
*                                                                     *
*           SWAPPABLE AND NON-SWAPPABLE:                              *
*                                                                     *
*    SWAP and    Setting an address space to be swappable or          *
*    NSWP need   non-swappable, is accomplished by executing          *
*    to run a    a SYSEVENT macro.  This has to execute in the        *
*    SYSEVENT    target address space, and it was done here by        *
*    macro in    scheduling an SRB to run in the target address       *
*    the         space, when it is different from the address         *
*    target      space running the program.  That piece of code       *
*    address     was written by     Reichman.  Thanks,    .           *
*    space       You did the hard part!                               *
*                                                                     *
*       NON-MEMTERMABLE AND MEMTERMABLE: (THE REAL "NON-FORCIBLE")    *
*                                                                     *
*    NMEM makes  In the ASCB of an address space there are two        *
*    a job both  bits, ASCBNOMT and less importantly, ASCBNOMD.       *
*    NON-FORCI-  ASCBNOMT controls the attribute, when it is on,      *
*    BLE and     that the address space is NON-MEMTERMABLE or         *
*    NON-CANCEL- NON-FORCIBLE.  If NON-CANCELABLE is also true,       *
*    ABLE.       as well as the non-memtermable bit ASCBNOMT,         *
*                then if you try and cancel the job, it will say,     *
*    MEMT makes  NON-CANCELABLE, and if you try and FORCE the         *
*    the job     job, it will say NON-FORCIBLE.  The two bits         *
*    FORCIBLE,   ASCBNOMT in the ASCB which has to be on, and         *
*    but leaves  the cancelable bit in the job's CSCB entry,          *
*    it to be    CNCL in flag CHACT, which has to be off,             *
*    NON-CANCEL- control this situation.                              *
*    ABLE.                                                            *
*                A job should not be left NON-FORCIBLE and            *
*                CANCELABLE.  That defeats the purpose of             *
*                NON-FORCIBLE, in that the job can easily             *
*                then be cancelled, because CANCEL will work.         *
*                                                                     *
*                The action NMEM (non-memtermable) sets both          *
*                then non-forcible bit in the ASCB on, and the        *
*                cancelable bit in the job's CSCB entry, off.         *
*                The action MEMT (make memtermable) turns only        *
*                the ASCBNOMT bit (non-memtermable) off, but          *
*                leaves the non-cancelable situation in place.        *
*                If you want to turn off non-cancelable later,        *
*                then the CNCL action will do this.                   *
*                                                                     *
*    -------------------------------------------------------------    *
*                                                                     *
*    BURN        BURN -  Kill the designated address space with a     *
*    (v 1.3.8)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *
*                                                                     *
*    -------------------------------------------------------------    *
*                                                                     *
*    KILL        KILL -  Kill the designated address space with a     *
*    (v 1.4.1)   CALLRTM TYPE=MEMTERM (like a FORCE).  Be careful !   *
*                KILL is a "super BURN".  Be VERY careful.....!       *
*                Before doing the MEMTERM, KILL turns off bits        *
*                in the ASCB (ASCBNOMT and ASCBNOMD), the             *
*                "non-FORCIBLE" bits.  Can whack any address space.   *
*    (v 1.4.2)   You need PSCB ACCOUNT authority to run BURN or KILL  *
*                along with OPER authority to run the rest of the     *
*                program.                                             *
*                                                                     *
*    -------------------------------------------------------------    *
*                                                                     *
*    NMEM and    NMEM will make the address space NON-FORCIBLE        *
*    MEMT        and NON-CANCELABLE.  MEMT will make the address      *
*    (v 1.4.3)   space FORCIBLE, but it will leave the cancelable     *
*                bit in place, however it was before.                 *
*                (Since the FORCE operator command actually equates   *
*                to a CALLRTM TYPE=MEMTERM macro call, making an      *
*                address space NON-FORCIBLE is also called making     *
*                it NON-MEMTERMABLE.                                  *
*                                                                     *
*    -------------------------------------------------------------    *
*                                                                     *
*    Syntax:     TSO Command:  APF-authorized.                        *
*                                                                     *
*        CNCLPG |jobid ÝASID(hhhh)¨ |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *
*               |ASID(hhhh)         |CNCL|NCNC|FORC|NFRC|NSWP|SWAP    *
*               |                   |CSCB or DISP                     *
*               |-  (displays the entire CSCB chain)                  *
*               |?  (displays help)                                   *
*               |                   |BURN                             *
*               |                   |KILL                             *
*               |                   |RLxO or RLxF   (1.3)             *
*               |                   |DACE           (1.3)             *
*               |                   |NMEM|MEMT                        *
*                                                                     *
*    Date:       April 15, 2010                                       *
*                                                                     *
*    Latest Modification:   May 23, 2017                              *
*                                                                     *
*                                                                     *
*                                                                     *
*    Technical Detail:  PUTLINE interface for TSO Output.             *
*                                                                     *
*                                                                     *
*    Changes:  1.  SWAP, NSWP support dropped from this program.      *
*                   Version is 1.0.0                                  *
*                                                                     *
*              2.  Messages and DISP improved, to just show matching  *
*                   CSCB chain entries, instead of all of them.       *
*                   - (dash) will show the entire CSCB chain.         *
*                                                                     *
*              3.  SWAP, NSWP support put back in this program.       *
*                   Version is 1.1.0   (June 16, 2010)                *
*                   It now does your own address space.  The cross    *
*                   memory stuff was not put in yet, for other        *
*                   address spaces.                                   *
*                                                                     *
*              4.  Now NSWP and SWAP works for all address spaces,    *
*                   with cross memory stuff now put in.  (1.2.1)      *
*                                                                     *
*              5.  RLxO or RLxF functionality.  (1.3.x)               *
*                                                                     *
*              6.  Burn an address space, if that is desired.         *
*                   (Oct 2013)  Version is 1.3.6.  Apply changes      *
*                   from between CNCLPG 1.2.0 and 1.2.5.              *
*                                                                     *
*              7.  Add DACE function to format and display            *
*                   another address space's ACEE.  (1.3.8)            *
*                                                                     *
*              8.  Fixed problem with R10 being used and overlaying   *
*                   the third base.  R5 substituted for R10 to fix.   *
*                                                                     *
*              9.  S047 protection for RLxx and DACE functions.       *
*                  Display 'Command was not invoked APF authorized.'  *
*                   instead of getting the S047 abend.                *
*                                                                     *
*             10.  Enhance FACEE program to include IHAACEE macro     *
*                   name fields.  (DACE function)  (1.3.9)            *
*                                                                     *
*             11.  Add 4 extra bits in ACEEFLG4 that can be flipped   *
*                   by the RLxx function.  (1.4.0)                    *
*                                                                     *
*             12.  Kill an address space.  Before you do the          *
*                  CALLRTM MEMTERM, the non-forcible flags in the     *
*                  ASCB are turned off.  (May 2017)  Version 1.4.1.   *
*                                                                     *
*             13.  Authority checking. So far, you need PSCB OPER     *
*                   to do anything. ACCT to do BURN or KILL.          *
*                   Version is 1.4.2.                                 *
*                                                                     *
*             14.  Make address space Non-Memtermable (can't be       *
*                   FORCEd), or Memtermable (can be FORCEd).          *
*                   Non-Memtermable implies Non-Cancelable, because   *
*                   it isn't effective if the address space is        *
*                   Cancelable but non-Memtermable).  You can easily  *
*                   get rid of it, and it defeats the purpose of      *
*                   non-Memtermable.  If you later make it            *
*                   Memtermable, you can make it Cancelable next.     *
*                   Version is 1.4.3.                                 *
*                                                                     *
*                                                                     *
*   change   pgmr                   description                       *
*   -------  -----   ----------------------------------------------   *
*                                                                     *
*   1.2.0             Add SRB code to allow nonswappable in xmem      *
*                                                                     *
*   1.3.0             Add RLxO and RLxF support                       *
*                                                                     *
*   1.3.1             Fix RLxO and RLxF support                       *
*                     Fix bug when not "on" or "off" code entered     *
*                      for RLx* function                              *
*                                                                     *
*   1.3.6             Add BURN function to this version. Apply        *
*                      changes from CNCLPG 1.2.0 to 1.2.5.            *
*                                                                     *
*   1.3.8             Add DACE to format another address space's      *
*                      ACEE and display its entire contents.          *
*                      Fix third base register overlay problem.       *
*                                                                     *
*   1.3.9             Enhance DACE function to include names of       *
*                      ACEE fields in macro IHAACEE.                  *
*                                                                     *
*   1.4.0             Add ACEEFLG4 bits that can be flipped by the    *
*                      RLxx function.                                 *
*                                                                     *
*   1.4.1             Add KILL function. Same as BURN but turn off    *
*                      the "no-MEMTERM" bits in the ASCB before       *
*                      doing the CALLRTM TYPE=MEMTERM.                *
*                      (The NON-FORCIBLE bits.)                       *
*                                                                     *
*   1.4.2             Add authority checking. Need PSCB OPER to even  *
*                     run the program. Additionally need ACCOUNT to   *
*                     run all functions based on the KILLFLAG. These  *
*                     are:  BURN, KILL, NMEM, MEMT.                   *
*                                                                     *
*   1.4.3             Add NMEM and MEMT options: Non-Memtermable      *
*                     and Memtermable.                                *
*                                                                     *
*  -----------------------------------------------------------------  *
*  This macro lets you display hex values in a report.                *
*  -----------------------------------------------------------------  *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    STM   R15,R1,HEXSAVE           Save work registers.
         LA    R1,&FROM                 Load from address.
         LA    R0,&LEN                  Load length of hex number.
         LA    R15,&TO                  Load to address.
         BAL   R9,HEX                   BAL to routine.
         LM    R15,R1,HEXSAVE           Restore work registers.
         MEND
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
* --       End of Internal Macros......                            -- *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
*   The CSCB chain of control blocks is above the line, so you need   *
*    to have AMODE 31.                                                *
* ------------------------------------------------------------------- *
CNCLPG   CSECT
CNCLPG   AMODE 31
CNCLPG   RMODE ANY
*-------------------------------------------------------------*
*        GENERAL PURPOSE REGISTERS                            *
*-------------------------------------------------------------*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*-------------------------------------------------------------*
*        ACCESS REGISTERS                                     *
*-------------------------------------------------------------*
AR0      EQU   0
AR1      EQU   1
AR2      EQU   2
AR3      EQU   3
AR4      EQU   4
AR5      EQU   5
AR6      EQU   6
AR7      EQU   7
AR8      EQU   8
AR9      EQU   9
AR10     EQU   10
AR11     EQU   11
AR12     EQU   12
AR13     EQU   13
AR14     EQU   14
AR15     EQU   15
*-------------------------------------------------------------*
*                  BEGIN THE ACTUAL CODE                      *
*-------------------------------------------------------------*
         USING CNCLPG,R15          (Establish temporary base).
         B     BEGIN               Skip over eyecatcher.
EYEC0    DC    AL1(EYECL)          Exclusive length of header.
EYEC     DC    C' CNCLPG - &SYSDATE - &SYSTIME -'   Eyecatcher
         DC    C' VER 1.4.3   '
         DC    C'   '
EYECL    EQU   *-EYEC
         DROP  R15                 (DROP TEMPORARY BASE).
BEGIN    STM   R14,R12,12(R13)     Save caller's registers
         LR    R6,R1               Preserve CPPL pointer.
         LR    R12,R15             Copy base.
         USING CNCLPG,R12,R11,R10  (Tell assembler).
         LA    R11,4095(,R12)      Load bases.
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LR    R14,R13             Copy caller's save area pointer.
         LA    R13,SAVE            Point to my save area.
         ST    R13,8(,R14)         Chain ...
         ST    R14,SAVE+4          ... Save areas.
*                                  Get PSCBATR1 byte and copy it
         ST    R1,SAVER1A          Save work register
         L     R1,16               CVTPTR
         L     R1,0(,R1)           TCB words
         L     R1,4(,R1)           Current TCB
         L     R1,180(,R1)         TCBJSCB
         L     R1,264(,R1)         JSCBPSCB
         LA    R1,0(,R1)           Clear hi order byte
         LTR   R1,R1               Is there a PSCB ?
         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg
         MVI   FLAG0,X'00'         Zero FLAG0 for safety
         MVC   FLAG0(1),X'10'(R1)  Overlay it with PSCBATR1
         L     R1,SAVER1A          Restore work register
AUTHTEST DS    0H
         TM    FLAG0,X'80'         PSCB OPER AUTHORITY?
         BZ    NOTFOUND            No, Issue COMMAND-NOT-FOUND msg
INITCON  DS    0H                  Initialize some constants.
         MVI   FLAG1,X'00'
         MVI   FLAG2,X'00'
         MVI   FLAG3,X'00'
         MVI   ONSWIT,X'00'
         MVI   RTMCOD,X'00'
         MVI   ERRASID,X'00'
         MVI   CANCINDC,X'00'
         MVI   KILLFLAG,X'00'
         MVI   OUTPUT-1,X'40'
         MVC   OUTPUT,OUTPUT-1
         MVI   NEWCHACT,X'00'
         L     R0,=V(ACEECSEC)     Save ACEE copy area CSECT entry      01729
         ST    R0,SAVACEEC          point and save it for later use.    01730
         L     R0,=V(FACEE)        Save entry point of FACEE which is
         ST    R0,SAVFACEE          ACEE formatting and dump program.
MYASID   DS    0H                  Get my own ASID.
         L     R2,X'224'           Point to PSAAOLD (my ASCB)
         LA    R2,X'24'(,R2)       Point to my own ASID (ASCBASID)
         MVC   OWNASID(2),0(R2)    Save it for comparison later
         B     PRTITLE             Branch past constant
*
OWNASID  DS    H                   Save my own ASID.
*
PRTITLE  DS    0H                  Print program title.
         APUT  MESSAGET,L'MESSAGET
         APUT  MESSAGEU,L'MESSAGEU
CONT0    DS    0H                  Look at command's parameters.
         LTR   R6,R6               Any CPPL?
         BZ    EOJ8                No.  Get out.
         L     R1,0(,R6)           Pt to cmd buffer. (R6 reused later)
         LTR   R1,R1               Any CMD buffer?
         BZ    EOJ8                Get out if none.
         LH    R3,0(,R1)           Load length.
         CH    R3,=H'4'            Anything?
         BNH   EOJ4                No. Get out.
         LR    R5,R3               Length of command + 4
         ICM   R5,14,FULLZERO      Clear hi order 3 bytes.
         LH    R3,2(,R1)           Load offset.
         SR    R5,R3               Subtract offset from full length+4
         SH    R5,=H'4'            Correct for length of cmdbufr header
         BC    8,WMESS2            Zero, message to enter userid.
         BC    5,EOJ8              Less, or overflow, out.
** ---------------------------------------------------------------- **
PARM     DS    0H                  Do all program functionality.
*                                  All the processing hooks off here.
         BAL   R9,GETIDS           Get parameters and execute
*                                   any function called for.
         B     EOJ0                Get out.
** ---------------------------------------------------------------- **
WMESS2   DS    0H                  Print help messages.
         BAL   R9,PRINTERR
         B     EOJ4
** ---------------------------------------------------------------- **
EOJ0     DS    0H                  End of job.
         APUT  RETURN0,L'RETURN0
         LA    R15,0               Set CC = 0.
         B     RETURN
EOJ4     DS    0H
         APUT  RETURN4,L'RETURN4
         LA    R15,4               Set CC = 4.
         B     RETURN
EOJ8     DS    0H
         APUT  RETURN8,L'RETURN8
         LA    R15,8               Set CC = 8.
         B     RETURN
RETURN   L     R13,SAVE+4          Return to caller.
         ST    R15,16(,R13)        Put RC into passed save area.
         LM    R14,R12,12(R13)
         BR    R14
** ---------------------------------------------------------------- **
NOTAUTH  DS    0H                  Command not APF authorized message.
         APUT  MESSAGNA,L'MESSAGNA
         B     EOJ4
** ---------------------------------------------------------------- **
NOTFOUND DS    0H                  Fake command not found message.
         APUT  MESSAGAU,L'MESSAGAU
         B     RETURN
** ---------------------------------------------------------------- **
NOTALLOW DS    0H                  Command NOT ALLOWED message.
         APUT  MESSAGAT,L'MESSAGAT
         B     RETURN
** ---------------------------------------------------------------- **
NOTMEMTM DS    0H                  Address space not MEMTERM-able.
         MVC   MESSAGNM+4(8),FOUNJOBI    Jobname into message
         HEX   MESSAGNM+22,2,FOUNASID    ASID into message
         APUT  MESSAGNM,L'MESSAGNM       Say job Not-Memterm-able
         APUT  MESSAGEL,L'MESSAGEL         and not burned,
         APUT  MESSAGFL,L'MESSAGFL
         BAL   R9,FORCHACT                 But show final status.
         B     RETURN
** ---------------------------------------------------------------- **
* ---           Everything after here is subroutines.            --- *
** ---------------------------------------------------------------- **
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                Get the parameters for the command.              *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   Notes:  The ASID(xxx) can be coded first, without a userid.   *
*           A dash can be coded first, to run the entire CSCB     *
*            chain and display all the jobnames in it, with       *
*            their associated ASIDs.  ? coded first gives HELP.   *
*           If you code the word CSCB or DISP(lay) after either   *
*            a jobname or an ASID(hhhh) then a display of ALL     *
*            matching CSCB chain entries will be displayed, and   *
*            no changes will be made.                             *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
GETIDS   DS    0H                  Get all parameters for the program.
         ST    R9,SAVER9A
         ST    R4,SAVER4C
         AR    R1,R3               Point ...
         LA    R1,4(,R1)           ... to char.
         LA    R6,8                Load reg for BCT loop.
         LR    R7,R1               Initialize pointer to first
         LA    R7,0(,R7)                character of the ID field.
         LA    R8,0                Initialize character count.
         MVC   JOBID(8),BLANKS     Clear (first param - JOBNAME) field.
         LA    R4,JOBID            Point reg to beginng of JOBID field.
*
CUTIDLEN DS    0H                  Look at the JOBID field first.
*                                  (May contain ASID( or CSCB.)
*
         CLI   0(R7),X'40'         Is this character a blank?
         BE    NOMORCUT            Yes, we are at the end of the field.
         MVC   0(1,R4),0(R7)       Move only one character at a time.
         OC    JOBID(8),BLANKS     And uppercase the partial jobid.
*
*   Is this a run of the CSCB chain only?
* -- >  Test for CSCB  first  ---- below
         CLI   JOBID,C'-'          Did we code '-' first?
         BNE   CSCBHELP            No. Try if help asked for.
         B     CSCBRUN1            Yes. Run entire CSCB chain.
* - > Help
CSCBHELP DS    0H
         CLI   JOBID,C'?'          Help?
         BNE   NOCSCB              No. Skip this code.
         BAL   R9,PRINTERR         Yes. Print messages
         B     EOJ0                  and get out with code 0.
* - > Help
CSCBRUN1 DS    0H
         ST    R8,SAVER8A          Store count for display if needed.
         OI    FLAG2,X'40'         Mark that this is CSCB only run.
         BAL   R9,RUNCSCB          Do the run for CSCB chain.
         B     EOJ0                Out with normal return code.
NOCSCB   DS    0H
* -- >  Test for CSCB  first  ---- above
*
*   Was the ASCB(hhh) parameter coded without the jobid?
* -- >  Test for ASID( first  ---- below
         CLC   JOBID(L'ASIDC),ASIDC  Did we code ASID( in jobid field?
         BNE   NOASIDF             No. Pass this code.
         OI    FLAG1,X'01'         Flag that ASID( ) was first.
         NI    FLAG1,X'FF'-X'02'   Turn off Jobname in jobid field flag
         MVC   ASIDWKL(L'ASIDC),JOBID  Move the ASID( to proper field.
         MVC   JOBID,BLANKS        Blank out Job ID if ASID( coded.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     ASIDONLY            Bypass all the real jobname stuff.
* -- >  Test for ASID( first  ---- above
NOASIDF  DS    0H                  ASID( is not the first parameter.
         LA    R4,1(,R4)           Bump another character.
         LA    R7,1(,R7)           Bump another character.
         LA    R8,1(,R8)           Count another character.
         CR    R8,R5               End of command buffer ?
         BNL   NOMORCUT            Yes. Get out now.
         BCT   R6,CUTIDLEN         Try for the next blank, up till 8.
NOMORCUT DS    0H
         STC   R8,SAVCOUNT         Save length of Jobname
         L     R4,SAVER4C          Restore work register for use later.
         OC    JOBID(8),BLANKS     Uppercase the new Job Id.
         OI    FLAG1,X'02'         Set 'Jobname Coded' flag.
*  -  Display the found JOBID - below
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search Jobname:'
         MVC   OUTPUT+17(8),JOBID
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL
*  -  Display the found JOBID - above
         LA    R6,1                Set number of branches later.
*                                  This will limit number of params
*                                   that are searched for.
         B     LOOKKEYW
*  Constants - below - ***
JOBID    DC    C'        '         STORE PARM USERID HERE
BLANKS   DC    C'        '         8 BLANKS
MESSAGET DC    C'CNCLPG 1.4.3 - Make a Job, STC or TSU Cancelable, etc.X
                (? for help)'
MESSAGEU DC   C'------ ----- - ---- - ---- --- -- --- ----------- ----'
MESSAGEL DC    C'----------------------------'
MESSAGEM DC    C'-----------------------------------------------'
MESSAG2A DC    C'Enter JOBNAME and/or ASID(hhhh) after COMMAND name,'
MESSAG2B DC    C'   then CNCL, NCNC, FORC, NFRC, NSWP, SWAP, CSCB or DIx
               SP.'
MESSAG2C DC    C'   DISPlay or CSCB will display CSCB chain entries,'
MESSAG2D DC    C'   without changing them.'
MESSAG2V DC    C'To get rid of the address space, code BURN or KILL.'
MESSAG2E DC    C' When affecting a job, we want to be accurate, '
MESSAG2F DC    C'  therefore you should use the DISPlay option first.'
MESSAG2Z DC    C'           SEE THE NOTES, BELOW.  '
MESSAG2G DC   C' To display the whole CSCB, code - (dash) for JOBNAME.'
MESSAG2H DC    C' To see this help message, code ? for JOBNAME.'
MESSAG2I DC    C'Notes :     ** VERY IMPORTANT TO READ **'
MESSAG2J DC   C' CSCB (DISP) display for an ASID shows all occurrences'
MESSAG2K DC    C'  for that ASID, regardless of JOBNAME.      '
MESSAG2L DC C' CSCB (DISP) display for a JOBNAME shows all occurrences'
MESSAG2M DC    C'  for that JOBNAME, regardless of ASID.      '
MESSAG2N DC    C' CNCL, NCNC, FORC, NFRC, NSWP, SWAP will change the FIx
               RST'
MESSAG2O DC    C'  entry in the CSCB chain that matches, if MULTIPLE '
MESSAG2P DC    C'  entries exist. But DISP will display ALL applicable'
MESSAG2Q DC    C'  matching entries in the CSCB chain, so you can see'
MESSAG2R DC    C'  which one you want to change specifically.'
MESSAG2S DC    C' When you code BOTH jobname and asid, to CHANGE it,'
MESSAG2T DC    C'  then ONLY that specific job and asid gets changed.'
MESSAGE3 DC    C'WE GOT HERE'
MESSAGE4 DC    C'TEST CHECK THIS'
MESSAGNG DC    C'Job was not done. SYSEVENT return code was     '
MESSAGNS DC    C'Job xxxxxxxx for ASID HHHH made non-swappable.'
MESSAGSW DC    C'Job xxxxxxxx for ASID HHHH was made swappable.'
MESSAGAN DC    C'Job xxxxxxxx for ASID HHHH already non-swappable.'
MESSAGAS DC    C'Job xxxxxxxx for ASID HHHH was already swappable.'
MESSAGFN DC    C'Function xxxx was called for.'
MESSAGBU DC    C'Job xxxxxxxx for ASID HHHH has been burned.'
MESSAGKI DC    C'Job xxxxxxxx for ASID HHHH has been killed.'
MESSAGAU DC    C'IKJ56500I COMMAND CNCLPGA NOT FOUND'
MESSAGAT DC    C'Lacking authority to execute this command.'
MESSAGNM DC    C'Job xxxxxxxx for ASID HHHH not MEMTERM-able. Not burnex
               d.'
MESSAGM1 DC    C'Job xxxxxxxx for ASID HHHH made non-memtermable.'
MESSAGM2 DC    C'Job xxxxxxxx for ASID HHHH was made memtermable.'
MESSAGFL DC    C'Final Job Status Report.'
RETURN0  DC    C'Return code is 0'
RETURN4  DC    C'Return code is 4'
RETURN4R DC    C'Return code is 4 from the SETRLD function'
RETURN8  DC    C'Return code is 8'
*                     ***  Places to save registers  ***  below
SAVER1A  DS    F
SAVER3A  DS    F
*AVER3B  DS    F
SAVER3C  DS    F
SAVER3D  DS    F
SAVER3E  DS    F
SAVER3F  DS    F
SAVER3G  DS    F
SAVER4A  DS    F
SAVER4B  DS    F
SAVER4C  DS    F
SAVER4D  DS    F
SAVER4E  DS    F
*AVER5A  DS    F
SAVER6A  DS    F
*AVER6B  DS    F
SAVER7A  DS    F
SAVER7B  DS    F
SAVER8A  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER9F  DS    F
SAVER9G  DS    F
SAVER9H  DS    F
SAVER9I  DS    F
SAVER9J  DS    F
SAVER9K  DS    F
SAVER9L  DS    F
*AVER9M  DS    F
*AVER9N  DS    F
SAVER9O  DS    F
*AVER9P  DS    F
*                     ***  Places to save registers  ***  above
SAVCOUNT DS    X
KILLFLAG DS    X
*              X'01'               KILL indicated
*              X'02'               BURN indicated  X'01' also on
*              X'04'               NMEM indicated
*              X'08'               MEMT indicated
DUBLZERO DC    D'0'
FULLZERO DC    F'0'
CANCINDC DC    X'00'
CANCKEY0 DC    X'00'
NEWCHACT DC    X'00'
*  Constants - above - ***
LOOKKEYW DS    0H                  Look for additional keywords.
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         CR    R8,R5               End of command buffer?
         BNL   GETIDEND            Yes. Don't look any more.
         MVC   ASIDWKL(5),BLANKS   Clear parameter work field.
         MVC   ASIDWKL(5),0(R7)    Next 5 characters to work field.
ASIDONLY DS    0H                  Jump to here if ASID( coded first.
         OC    ASIDWKL(4),BLANKS   Uppercase work field.
         CLC   ASIDC,ASIDWKL       Is the ASID( keyword there?
         BE    DOASID              Yes. Process it.
         CLC   CNCLC,ASIDWKL       Is the CNCL  keyword there?
         BE    DOCNCL              Yes. Process it.
         CLC   NCNCC,ASIDWKL       Is the NCNC  keyword there?
         BE    DONCNC              Yes. Process it.
         CLC   SWAPC,ASIDWKL       Is the SWAP  keyword there?
         BE    DOSWAP              Yes. Process it.
         CLC   NSWPC,ASIDWKL       Is the NSWP  keyword there?
         BE    DONSWP              Yes. Process it.
         CLC   FORCC,ASIDWKL       Is the FORC  keyword there?
         BE    DOFORC              Yes. Process it.
         CLC   NFRCC,ASIDWKL       Is the NFRC  keyword there?
         BE    DONFRC              Yes. Process it.
         CLC   CSCBC,ASIDWKL       Is the CSCB  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   DISPC,ASIDWKL       Is the DISP  keyword there?
         BE    DOCSCB              Yes. Process it.
         CLC   RL,ASIDWKL          Is RLxO or RLxF there?
         BE    DOACEE              Yes. Process it.
         CLC   BURNC,ASIDWKL       Is the BURN  keyword there?      BUR
         BE    DOBURN              Yes. Process it.                 BUR
         CLC   KILLC,ASIDWKL       Is the KILL  keyword there?      KIL
         BE    DOKILL              Yes. Process it.                 KIL
         CLC   NMEMC,ASIDWKL       Is the NMEM  keyword there?
         BE    DONMEM              Yes. Process it.
         CLC   MEMTC,ASIDWKL       Is the MEMT  keyword there?
         BE    DOMEMT              Yes. Process it.
         CLC   DACEC,ASIDWKL       Is the DACE  keyword there?
         BE    DODACEE             Yes. Process it.
         B     LOOKKEYW            Go loop and look at next character.
ASIDWKL  DC    CL5' '              Second parameter work area.
*
ASIDC    DC    C'ASID('            Literals....
CNCLC    DC    C'CNCL'
NCNCC    DC    C'NCNC'
SWAPC    DC    C'SWAP'
NSWPC    DC    C'NSWP'
FORCC    DC    C'FORC'
NFRCC    DC    C'NFRC'
CSCBC    DC    C'CSCB'
DISPC    DC    C'DISP'
RL       DC    C'RL'
BURNC    DC    C'BURN'
KILLC    DC    C'KILL'
NMEMC    DC    C'NMEM'
MEMTC    DC    C'MEMT'
DACEC    DC    C'DACE'
*
DOASID   DS    0H                  Look for hex value of the ASID.
         OI    FLAG1,X'04'         Show that ASID( was coded.
         BAL   R9,GETASID          Go get the rest of the parameters.
         MVC   ASIDWKL(5),BLANKS   Blank out the second wkarea for
*                                   a further parameter search.
         B     LOOKKEYW            Re-loop to look further for params.
*
DOCNCL   DS    0H                  Handle CNCL (cancelable) keyword.
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'01'         Show that CNCL was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
* ------------------------------------------------------------------- *
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CNCLC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONCNC   DS    0H                  Handle NCNC (non-cancelable) keyword
         OI    CANCINDC,X'08'      Show which CHACT bit is affected.
         OI    FLAG2,X'02'         Show that NCNC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*                                    Print the action code.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NCNCC
         APUT  OUTPUT,25
*                                    Print the bit in CHACT affected.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOSWAP   DS    0H                  Not active yet.
         OI    FLAG2,X'04'
         MVC   MESSAGFN+9(4),SWAPC
         APUT  MESSAGFN,L'MESSAGFN
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         BAL   R9,KEY0SWNS
         BCT   R6,LOOKKEYW
         B     GETIDEND
* ------------------------------------------------------------------- *
DONSWP   DS    0H                  Not active yet.
         OI    FLAG2,X'08'
         MVC   MESSAGFN+9(4),NSWPC
         APUT  MESSAGFN,L'MESSAGFN
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         BAL   R9,KEY0SWNS
         BCT   R6,LOOKKEYW
         B     GETIDEND
* ------------------------------------------------------------------- *
DOFORC   DS    0H                  Handle FORC (forcible) keyword
         OI    FLAG2,X'10'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that FORC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'01'        Set to OR the bits
         NI    ONSWIT,X'FF'-X'02'   and not to AND the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),FORCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DONFRC   DS    0H                  Handle NFRC (non-forcible) keyword
         OI    FLAG2,X'20'         Show which CHACT bit is affected.
         OI    CANCINDC,X'01'      Show that NFRC was coded.
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match.
         OI    ONSWIT,X'02'        Set to AND the bits
         NI    ONSWIT,X'FF'-X'01'   and not to OR the bits.
         BAL   R9,KEYZERO          Do the Key 0 changes to CSCB entry.
         BAL   R9,PRNWCSCB         Print the info from the current CSCB
         BAL   R9,FORCHACT         Format the relevant CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline.
*
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),NFRCC
         APUT  OUTPUT,25
*
         MVC   OUTPUT,OUTPUT-1       Print the bit in CHACT affected.
         MVC   OUTPUT(23),=C'Cancel Indicator Flag :'
         HEX   OUTPUT+25,1,CANCINDC
         APUT  OUTPUT,30
*
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOCSCB   DS    0H
         OI    FLAG1,X'08'         Show CSCB keyword was coded.
         OI    FLAG2,X'40'         Show CSCB keyword was coded.
         MVC   OUTPUT,OUTPUT-1       Print the action code.
         MVC   OUTPUT(15),=C'Action code   :'
         MVC   OUTPUT+17(4),CSCBC
         MVC   OUTPUT+23(9),=C'(DISPlay)'
         APUT  OUTPUT,35
         BAL   R9,RUNCSCB          Run the CSCB chain with print.
         BCT   R6,LOOKKEYW         Look for another keyword.
         B     GETIDEND            After enough looks, end.
* ------------------------------------------------------------------- *
DOACEE   DS    0H                  Not active yet.
         MVC   MESSAGFN+9(4),ASIDWKL  Display entered
         APUT  MESSAGFN,L'MESSAGFN       function code.
*
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
*
         BAL   R9,SETRLD           Do RL function.
         TM    FLAG3,X'01'         Not "on" or "off"?
         BO    EOJ4                Report error.
         B     GETKEYNR            End normally.
* ------------------------------------------------------------------- *
GETIDEND DS    0H                  End of keyword processing.
         TM    FLAG2,X'FF'         Check if any real actions asked  BUR
         BNZ   GETKEYNR            Yes, some were.
         APUT  MESSAGEY,L'MESSAGEY    No. Display help messages.
         BAL   R9,PRINTERR
         B     EOJ4                   And end with code = 4.
GETKEYNR DS    0H                  Real actions WERE asked for.
         TM    KILLFLAG,X'FF'      Any of the KILLFLAG options on?
         BZ    SKPKEYNR            No, no extra printout.
         TM    KILLFLAG,X'03'      If kill, then don't need status.
         BNZ   SKPKEYNR
GETKEYNS DS    0H                  Real actions WERE asked for.
         APUT  MESSAGEL,L'MESSAGEL
         APUT  MESSAGFL,L'MESSAGFL
         BAL   R9,FORCHACT         Show summary after actions.
SKPKEYNR DS    0H                  Real actions WERE asked for.
         B     EOJ0                So end with normal return code.
         L     R9,SAVER9A
         BR    R9
** ---------------------------------------------------------------- **
SETRLD   DS    0H                  Do the RL function
         BAKR  R9,0                Save all registers on the stack
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match
         BAL   R9,GETASCB          Get the ASCB number
         LR    R9,R15              Point to ASCB
         L     R9,0(,R9)            Point to ASCB
         L     R5,ASCBASXB-ASCB(,R9)   Get ASXB
*--------------------------------------------------------------*
*                    Get bit setting                           *
*--------------------------------------------------------------*
         LA    R9,ACEETBL         Get ACEE table with bit settings
         USING ACEEFC,R9          Address our table
LOOKFUN  DS    0H                 Loop thru table
         CLI   FUNCT,255          Not found - end of table
         BE    ERROR              Error; get out
         CLC   FUNCT,ASIDWKL+2    Found function?
         BE    FOUFUNC            YES;
         LA    R9,3(,R9)          NEXT
         B     LOOKFUN            LOOK FOR FUNCTION AGAIN
FOUFUNC  DS    0H
         MODESET MODE=SUP,KEY=ZERO
         XR    R6,R6              Clear all Registers
         LH    R6,FOUNASID        Get Asid
         LA    R2,1               Give us AUTHORITY
         AXSET AX=(2)
         SSAR  R6                 Set SECONDARY ADDRESS SPACE
         SAC   512                AR MODE
         USING ACEE,R5            Address ACEE
         LAM   R9,R9,=F'0'
         LAM   AR7,AR7,=F'1'      SECONDARY ADDRESS SPACE
         LAM   AR5,AR5,=F'1'      SECONDARY ADDRESS SPACE
         L     R5,ASXBSENV-ASXB(,R5) Get ACEE
         LA    R7,ACEEFLG1        Get flag one
         XR    R8,R8              clear r8
         IC    R8,DISP            get disp
         LA    R7,0(R8,R7)        Point to byte
         CLI   ASIDWKL+3,C'F'     Turn  it off
         BE    OFF                YES;
         CLI   ASIDWKL+3,C'O'     Turn  it on
         BE    BITON              YES;
         OI    FLAG3,X'01'        ERROR has been marked
         B     RESET              Back to normal mode
BITON    DS    0H
         OC    0(1,R7),BITSET     set the bit
         B     RESET
OFF      DS    0H
         MVI   BYTE,255           all f's
         XC    BYTE,BITSET        Flip the bits
         NC    0(1,R7),BYTE       turn it off
RESET    DS    0H
         LH    R6,OWNASID         re-set sasid
         SSAR  R6
         SAC   0
         LAM   AR5,AR5,=F'0'      SECONDARY ADDRESS SPACE
         LAM   AR7,AR7,=F'0'      SECONDARY ADDRESS SPACE
         MODESET KEY=NZERO,MODE=PROB
         TM    FLAG3,X'01'        Not "on" or "off" command?
         BO    ERROR              Bad command. Show error. Code 4.
RETZERO  DS    0H
         XR    R15,R15            Clear return code
         B     RET
ERROR    DS    0H                 Don't do actions, display entered
         APUT  RETURN4R,L'RETURN4R
         LA    R15,4                function, and show help.
RET      DS    0H
         PR
** ---------------------------------------------------------------- **
* ------------------------------------------------------------------- *
DODACEE  DS    0H                  Display this ASID's ACEE
         MVC   MESSAGFN+9(4),ASIDWKL  Display entered
         APUT  MESSAGFN,L'MESSAGFN       function code.
*
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
*
         BAL   R9,SETDACEE         Do DACE function.
         B     GETKEYNR            RETURN
SETDACEE DS    0H                  Do the DACE function
         BAKR  R9,0                Save all registers on the stack
         BAL   R9,FINDCSCB         Look thru CSCB chain for a match
         BAL   R9,GETASCB          Get the ASCB number
         LR    R9,R15              Point to ASCB
         L     R9,0(,R9)            Point to ASCB
         L     R5,ASCBASXB-ASCB(,R9)   Get ASXB
*--------------------------------------------------------------*
COPYACEE DS    0H                  Mimic the RL code to get ACEE
         MODESET MODE=SUP,KEY=ZERO
         XR    R6,R6               Clear all Registers
         LH    R6,FOUNASID         Get Asid
         LA    R2,1                Give us AUTHORITY
         AXSET AX=(2)
         SSAR  R6                  Set SECONDARY ADDRESS SPACE
         SAC   512                 AR MODE
         USING ACEE,R5             Address ACEE
         LAM   R9,R9,=F'0'
         LAM   AR7,AR7,=F'1'       SECONDARY ADDRESS SPACE
         LAM   AR5,AR5,=F'1'       SECONDARY ADDRESS SPACE
         L     R5,ASXBSENV-ASXB(,R5) Get ACEE
         ST    R3,SAVER3G          Save
         ST    R4,SAVER4E            work registers
         L     R3,SAVACEEC         Get other adrspc's ACEE
         USING ACEECSEC,R3
         XC    ACEECOPY,ACEECOPY   Clear the area out
         MVC   ACEECOPY(192),0(R5) Do the cross addrspc copy
         ST    R5,ACEEADDR
         LH    R6,OWNASID          re-set sasid
         SSAR  R6
         SAC   0
         LAM   AR5,AR5,=F'0'       SECONDARY ADDRESS SPACE
         LAM   AR7,AR7,=F'0'       SECONDARY ADDRESS SPACE
         MODESET KEY=NZERO,MODE=PROB
* -----------------------          Continue using the gotten data.
*        APUT  ACEECOPY,96         Test display to see if the
*        APUT  ACEECOPY+96,96       gotten data is correct.
* -----------------------
*                                  Call FACEE program to display
*                                   the gotten ACEE block info.
         L     R15,SAVFACEE        Load entry pt of FACEE program.
         XR    R1,R1               Clear R1 to be sure.
         L     R1,SAVACEEC         Load address of ACEE image.
         BALR  R14,R15             Call FACEE to display the data.
         DROP  R3
         L     R3,SAVER3G          Restore
         L     R4,SAVER4E            work registers
         XR    R15,R15             Clear return code
         PR
SAVACEEC DC    A(0)                Address of ACEE gotten copy
SAVFACEE DC    A(0)                Address of FACEE entry point
** ---------------------------------------------------------------- **
ACEETBL  DC    C'S',X'80',X'00'     ACEESPEC
         DC    C'O',X'20',X'00'     ACEEOPER
         DC    C'U',X'10',X'00'     ACEEAUDT
         DC    C'P',X'02',X'00'     ACEEPRIV
         DC    C'K',X'01',X'00'     ACEERACF
         DC    C'A',X'80',X'01'     ACEEALTR
         DC    C'C',X'40',X'01'     ACEECNTL
         DC    C'D',X'20',X'01'     ACEEUPDT
         DC    C'R',X'10',X'01'     ACEEREAD
         DC    C'0',X'01',X'01'     ACEENONE
         DC    C'G',X'80',X'02'     ACEEGRPA
         DC    C'N',X'01',X'02'     ACEENPWR
         DC    C'H',X'20',X'12'     ACEEUATH
         DC    C'V',X'08',X'12'     ACEEDASD
         DC    C'T',X'04',X'12'     ACEETAPE
         DC    C'M',X'02',X'12'     ACEETERM
         DC    X'FF'
*
ACEEFC   DSECT
FUNCT    DS   C                     FUNCTION
BITSET   DS   X                     Bit Setting
DISP     DS   X                     Displacement from ACEEFLG1
CNCLPG   CSECT                      Reestablish
BYTE     DS   X
** ---------------------------------------------------------------- **
HEX      DS    0H                  Display hex values.
         ST    R9,SAVER9B
         MVC   1(1,R15),0(R1)      Move byte.
         UNPK  0(3,R15),1(2,R15)   Unpack.
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         Increment output pointer.
         LA    R1,1(,R1)           Increment input pointer.
         BCT   R0,HEX              Decrement length, then loop.
         MVI   0(R15),C' '         Blank the trailing byte.
         L     R9,SAVER9B
         BR    R9                  Return to caller.
HEXTAB   DC    C'0123456789ABCDEF' Translate table.
** ---------------------------------------------------------------- **
GETASID  DS    0H                  Get hex ASID for 2 bytes.
         ST    R9,SAVER9C          Save registers.
         STM   R1,R6,SAVERGS1
         LA    R6,4                Load BCT register.
         LA    R4,ASIDWK           Point to ASID work area.
         TM    FLAG1,X'02'         Ask if Job name was coded.
         BZ    GETAFL01            Wasn't. Have to adjust pointers.
         LA    R7,5(,R7)           Bump command buffer pointer.
         LA    R8,5(,R8)           Bump character counter.
GETAFL01 DS    0H
GETASIDL DS    0H                  Loop to get hex ASID for 4 display
*                                    bytes to convert to 2 hex bytes.
         CLI   0(R7),C')'          Have we reached close parenthesis?
         BE    GETASIDG            Yes, assume we've got it.
         CLI   0(R7),C' '          Have we hit a blank?
         BE    GETASIDG            Yes, assume we've got it.
         MVC   0(1,R4),0(R7)       Otherwise move one character over.
         LA    R4,1(,R4)           Bump one ASIDWK character (target)
         LA    R7,1(,R7)           Bump command buffer pointer.
         LA    R8,1(,R8)           Bump character counter.
         BCT   R6,GETASIDL         Loop for 4 characters.
         B     GETASIDG            We don't look for more than 4.
GETASIDG DS    0H
*        APUT  ASIDWK,4
         LA    R4,ASIDWK           Point register at workarea again.
         LA    R1,4                Maximum of 4 characters.
GETASIDA DS    0H
         CLI   3(R4),X'40'         Is last character a blank (<4 total)
         BNE   GETASIDM            No. We're finished sliding.
         BCTR  R4,0                Slide the pointer one place back.
         BCT   R1,GETASIDA         Do it no more than 4 times.
GETASIDM DS    0H
         MVC   ASIDMV(4),0(R4)     Move 4 characters so last one
*                                     is not blank.
         MVC   ASIDWKSV(4),ASIDMV    Save these 4 characters
         MVC   ASIDWKS(4),ASIDMV        in two places.
         MVC   OUTPUT,OUTPUT-1       Clear output line.
         MVC   OUTPUT(25),ASIDMSG    Move coded display format asid.
         APUT  OUTPUT,40             And put out the message.
         TR    ASIDMV(4),ASIDVAL     Translate display format message
*                                      into format X'0h0h0h0h'.
*        MVC   OUTPUT,OUTPUT-1       Test display of hex result.
*        HEX   OUTPUT,4,ASIDMV
*        APUT  OUTPUT,10
         BAL   R9,VALIDTR            Validity check the hex number.
         PACK  ASIDGET(3),ASIDMV(5)  Get rid of all zone nibbles.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(15),=C'Search ASID   :' Print resulting 2-bytes
         HEX   OUTPUT+21,2,ASIDBIN
         APUT  OUTPUT,30
         APUT  MESSAGEL,L'MESSAGEL   Add underline for clear display.
*
GETASIDE DS    0H                    End of routine.
         LM    R1,R6,SAVERGS1        Restore registers
         L     R9,SAVER9C               and
         BR    R9                          exit.
** ----------------------------------------------------------------
*
*   GETASCB return ASCB give the asid of address space
*
*
*
*  Input:
*      FOUNASID = ASID
*  OutPut:
*      r15 = 0    Error
*      r15 = ASCB
** ----------------------------------------------------------------
GETASCB  DS    0H
         ST    R9,SAVER9O            Save Register
         L     R15,CVTPTR            R15 -> cvt
         L     R15,CVTASVT-CVT(,R15)  R15 -> asvt
         USING ASVT,R15
         CLC   ASVTASVT-ASVT(4,R15),=C'ASVT'  check eyecatcher
         BNE   NOASCB
         LA    R15,ASVTENTY-ASVT(,R15) Get first asvt slot
         LH    R0,FOUNASID           Get asid in question
         BCTR  R0,0                  Down By 1
         SLL   R0,2                  Multiply by 4
         AR    R15,R0                Point to ASCB
         BR    R9
NOASCB   DS    0H
         XR    R15,R15               Clear r15
         L     R9,SAVER9O            Restore Register
         BR    R9
ASIDWKB  DC    CL4'    '
ASIDWK   DC    CL4'    '
ASIDWKF  DC    CL4' '
ASIDMV   DC    CL4'    '
ASIDMVF  DC    CL4' '
ASIDBIN  DS    0XL2
ASIDGET  DC    XL4'00000000'

SAVERGS1 DS    6F
*                   Translate table to validity check ASID.
*                     Convert display values to X'0h'
*                     (where h is the hex value).
ASIDVAL  DS    0D
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CC0A0B0C0D0E0FCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC'
         DC    XL16'00010203040506070809CCCCCCCCCCCC'
FILLER1  DS    CL8
ASIDMSG  DC    CL21'ASID parm entered  : '
ASIDWKSV DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
FINDCSCB DS    0H                  Find CSCB entry to change or report.
         ST    R9,SAVER9D          Save registers.
         ST    R3,SAVER3A
FINDCSST DS    0H                  Get the first CSCB.
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         USING CHAIN,R3            Tell assembler.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
FINDCSLP DS    0H                  Loop through the CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB Jobid (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
* ------------------------------------------------------------------- *
* We first try to match a JOBID if coded, to the job id in this CSCB. *
* If equal, we see if an ASID has been coded, and both have to match. *
* Otherwise, with no match, we go to the end of the CSCB chain.       *
* ------------------------------------------------------------------- *
FINDCSMY DS    0H                  Find the CSCB that I want.
         TM    FLAG1,X'04'         Was ASID( coded at all?
         BZ    FINDCSJB            No. Just find a JOBID match.
         TM    FLAG1,X'01'         Is the JOB id missing?
         BO    FINDCSAS            Yes, just look for an ASID match.
         TM    FLAG1,X'02'         Was JOB id coded?
         BO    FINDCSJB            Yes. Look for it.
         ICM   R3,15,0(R3)         Go to next CSCB.
         BZ    FINDCSEC            If zero, we are at end of CSCB chain
         B     FINDCSLP            Look at next CSCB entry in table.
FINDCSJB DS    0H                  Check for JOBID match in this CSCB.
         CLC   JOBID(8),CSCBJOBI   Compare coded JOBID to CSCB jobname.
         BE    FINDCSIA            Equal, check if ASID is there.
         ICM   R3,15,0(R3)         Otherwise go to the next CSCB.
         BZ    FINDCSEC            Zero, end of the CSCB chain.
         B     FINDCSLP            Not zero, look at the next entry.
FINDCSIA DS    0H
         TM    FLAG1,X'04'         Was ASID( coded?
         BZ    FINDCSFD            No. Found it on just a job match.
*                                   So this is the first job that
*                                   matched, if there are multiple
*                                   jobs with the same name.
FINDCSAS DS    0H                  Check the ASID in the CSCB.
         CLC   ASIDBIN(2),CSCBASID Is this our ASID? Does it match.
         BE    FINDCSFD            I guess we found it.
         ICM   R3,15,0(R3)         Go to the next CSCB.
         BZ    FINDCSEC            Zero marks the end of the CSCB chain
         B     FINDCSLP            Not zero. Look at the next entry.
FINDCSFD DS    0H                  Our CSCB has been found.
         ST    R3,FOUNCSCB         Save found CSCB address.
         MVC   FOUNACTF,CHACT      Save
         MVC   SAVEACTF,CHACT      Save
         MVC   FOUNJOBI,CHKEY        CSCB
         MVC   FOUNPROC,CHCLS          info.
         MVC   FOUNASID,CHASID
         MVC   SAVEASID,CHASID
         BAL   R9,PRNTCSCB         Print info from the current CSCB.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Put out an underline.
         B     FINDCSEN            Go to end of routine.
         DROP  R3
FINDCSEC DS    0H                  Came to end of CSCB chain.
         APUT  MESSAGEN,L'MESSAGEN   Then put out a message
         B     EOJ4                  And end with code 4.
FINDCSEN DS    0H
         L     R3,SAVER3A
         L     R9,SAVER9D
         BR    R9
*            Constants associated with this routine.    -    below
FOUNACTF DC    X'00'
SAVEACTF DC    X'00'
FOUNCSCB DS    F                   FOUND CSCB ADDRESS
FOUNJOBI DC    CL8' '
FOUNPROC DC    CL8' '
FOUNASID DC    H'0'
SAVEASID DC    H'0'
CSCBACTF DC    X'00'
CSCBJOBI DC    CL8' '
CSCBPROC DC    CL8' '
CSCBASID DC    H'0'
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
VALIDTR  DS    0H                  Validate hex characters coded.
         ST    R9,SAVER9E          Save
         STM   R4,R6,SAVEWRK          registers.
         LA    R4,ASIDMV           Point to translated display chars.
         LA    R6,ASIDWKS          Point to chars with error signs.
         LA    R5,4                BCT register - only 4 times.
VALIDTRS DS    0H
         CLI   0(R4),X'CC'         Is this an invalid character?
         BE    VALIDTRR            Yes. Substitute a ? for message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char for error message.
         BCT   R5,VALIDTRS         Loop to test validity of this char.
         TM    ERRASID,X'01'       After 4 chars, any errors found?
         BO    VALIDERR            Yes. Write messages.
         B     VALIDTRE            No. Get out of routine.
VALIDTRR DS    0H                  Come here if invalid char found.
         OI    ERRASID,X'01'       Flag that at least one was found.
         MVI   0(R6),C'?'          Substitute a ? for it in message.
         LA    R4,1(,R4)           Next translated character.
         LA    R6,1(,R6)           Next char in error message.
         BCT   R5,VALIDTRS         Check that character for validity.
VALIDERR DS    0H                  Error messages if char is invalid.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(37),ASIDBADM
         APUT  OUTPUT,45
*        MVC   OUTPUT,OUTPUT-1
*        MVC   OUTPUT(51),MSGBADPR
*        APUT  OUTPUT,52
         B     EOJ4                Get out with code 4.
VALIDTRE DS    0H
         L     R4,SAVER4B          Restore regs used in this routine.
         LM    R4,R6,SAVEWRK
         BR    R9
*            Constants associated with this routine.    -    below
ERRASID  DC    X'00'
SAVEWRK  DS    3F
MSGBADPR DC    C'Bad ASID entered. Use end parenthesis ) to delimit.'
ASIDBADM DC    CL33'Bad Characters marked with a ?:  '
ASIDWKS  DC    CL4' '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
* -- -- -- -- -- -- -- -- -- -- -- --    R3 points to a CSCB address
PRNTCSCB DS    0H                  Print a CSCB entry.
         ST    R9,SAVER9F          Save BAL register.
         ST    R3,SAVECSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from current CSCB
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         TM    FLAG2,X'80'                Is this a BURN or KILL?   KIL
         BO    PRNTFINI                   Yes. Abridge the messages BUR
         TM    FLAG2,X'40'                CSCB only run. i.e. DISPLAY
         BO    PRNTCSC1
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Previous CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         B     PRNTCSC2
PRNTCSC1 DS    0H
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Current  CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
PRNTCSC2 DS    0H
         DROP  R3
PRNTFINI DS    0H
         L     R3,SAVECSCB         Restore register to what it was.
         L     R9,SAVER9F          Restore BAL register and
*                                     branch back to caller.
         BR    R9
SAVECSCB DS    F                   Saved address of found CSCB.
** ---------------------------------------------------------------- **
RUNCSCB  DS    0H                  Run through the CSCB chain.
         ST    R9,SAVER9G
         ST    R3,SAVER3C
         ST    R7,SAVER7A
RUNCSCBT DS    0H
         TM    FLAG2,X'40'         Only run if CSCB keyword was coded.
         BZ    RUNCSCBE            Not coded, get out.
*                                  Display this is a CSCB chain run.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(40),=C'This is a run of the CSCB Chain only ...'
         APUT  OUTPUT,45
         APUT  MESSAGEL,L'MESSAGEL   Print underline.
*                                  Find the CSCB chain:
         L     R3,16               CVT
         L     R3,X'94'(,R3)       MSER - pointer to CSCB chain.
         ICM   R3,15,0(R3)         First CSCB entry.
         BZ    RUNCSCBE            If zero, end of CSCB chain.
*                                  Otherwise points to next CSCB in
*                                    the table.
         USING CHAIN,R3
RUNCSCBD DS    0H                  Loop through CSCB entries.
         MVC   CSCBACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   SAVEACTF(1),CHACT     Save CSCB ACT flag for this CSCB.
         MVC   CSCBJOBI(8),CHKEY     Save CSCB JOBID (CHKEY).
         MVC   CSCBPROC(8),CHCLS     Save CSCB PROC id (CHCLS).
         MVC   CSCBASID(2),CHASID    Save CSCB ASID (CHASID).
         MVC   SAVEASID(2),CHASID    Save CSCB ASID (CHASID).
*  Test
*        MVC   OUTPUT,OUTPUT-1
*        HEX   OUTPUT,2,CHASID
*        HEX   OUTPUT+6,2,ASIDBIN
*        MVI   OUTPUT+15,C'i'
*        APUT  OUTPUT,25
*  Test
* -- Limit print of entries to Jobname or ASID only ----  below
         CLI   JOBID,C'-'          Are we printing the whole CSCB?
         BE    RUNCSCBY            Yes.
         CLC   ASIDBIN,=X'0000'    Was an ASID coded for a search?
         BNE   RUNCSCB2            No. Just check for Jobname.
RUNCSCB1 DS    0H                  Check for Jobname match.
         XR    R7,R7               Clear work register.
         IC    R7,SAVCOUNT         Insert saved length of Jobid.
         BCTR  R7,0                Decrement for execute.
         EX    R7,RUNCSCOM         Do the compare for proper length.
*        BNE   RUNCSCBS            Not equal, don't print result.
         BE    RUNCSCBP            Equal, print this CSCB entry.
RUNCSCB2 DS    0H                  Check if ASID was coded.
         CLC   ASIDBIN,CHASID      ASID match?
         BNE   RUNCSCBS            No. Skip print of CSCB entry.
RUNCSCBY DS    0H
* -- Limit print of entries to Jobname or ASID only ----  above
RUNCSCBP DS    0H                  Print this entry....
         BAL   R9,PRNTCSCB         Print of current CSCB information.
         BAL   R9,FORCHACT         Format some CHACT flags.
         APUT  MESSAGEL,L'MESSAGEL   Print an underline line.
RUNCSCBS DS    0H                  If skipping an entry print, go here.
         ICM   R3,15,0(R3)         Go to next CSCB entry in table.
         BZ    RUNCSCBE            If it is zero, end of CSCB chain.
         B     RUNCSCBD            Not zero, loop to next entry and
*                                    print it.
RUNCSCBE DS    0H                  End of routine.
         L     R3,SAVER3C          Restore
         L     R7,SAVER7A
         L     R9,SAVER9G             registers and
         BR    R9                        go back to caller.
RUNCSCOM CLC   JOBID(*-*),CHKEY   Executed
         DROP  R3
** ---------------------------------------------------------------- **
KEYZERO  DS    0H                  Into Key 0 and change CSCB cntl blk.
         ST    R9,SAVER9H
         ST    R4,SAVER4A
*
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
*
* -- >    ***    Do as little as possible under Key 0.    ***
KEYPRLIM DS    0H
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    SWITOFF             No. Try AND-ing?
         MVC   CANCKEY0,CANCINDC   Pre-process affecting bits.
         B     SWITON              All done pre-processing.
SWITOFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0BYPS            No. Don't do anything else.
         XC    CANCINDC,=X'FF'     Reverse the affected bits for AND.
         MVC   CANCKEY0,CANCINDC   And move them to staging area.
SWITON   DS    0H
         USING CHAIN,R3
         L     R3,FOUNCSCB         Save address of "found CSCB".
*
* -- >                             We're authorized. Go Key 0.
         MODESET KEY=ZERO
         TM    ONSWIT,X'01'        Are we OR-ing?
         BZ    KEY0OFF             No. Try AND-ing.
         OC    CHACT(1),CANCKEY0   Do the OR.
         B     KEY0END             Out of Key 0.
KEY0OFF  DS    0H
         TM    ONSWIT,X'02'        Are we AND-ing?
         BZ    KEY0END             No. Get out altogether.
         NC    CHACT(1),CANCKEY0   Do the AND.
KEY0END  DS    0H                  Out of Key 0.
         MODESET KEY=NZERO
*
KEY0BYPS DS    0H                  Key 0 bypass - branch to here.
         MVC   SAVEACTF(1),CHACT   Record for posterity
         DROP  R3
         L     R4,SAVER4A
         L     R9,SAVER9H
         BR    R9
** ---------------------------------------------------------------- **
PRNWCSCB DS    0H                  Print the changed CSCB entry.
         ST    R9,SAVER9I          Save BAL register.
         ST    R3,SAVER3D
         L     R3,FOUNCSCB         Saved found CSCB address.
         USING CHAIN,R3
*                   Print info from changed CSCB.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Job  ID :'
         MVC   OUTPUT+11(8),CHKEY
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'Proc ID :'
         MVC   OUTPUT+11(8),CHCLS
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(9),=C'ASID    :'
         HEX   OUTPUT+11,2,CHASID
         APUT  OUTPUT,25
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(21),=C'Modified CHACT Flags:'
         HEX   OUTPUT+23,1,CHACT
         APUT  OUTPUT,25
         APUT  MESSAGEL,L'MESSAGEL
         DROP  R3
         L     R3,SAVER3D          Restore register to what it was.
         L     R9,SAVER9I          Restore BAL register and
         BR    R9                     branch back to caller.
** ---------------------------------------------------------------- **
**             REPORT - Format the CHACT Flags - REPORT             **
** ---------------------------------------------------------------- **
FORCHACT DS    0H                  SAVEACTF less volatile than CHACT.
         ST    R9,SAVER9J          Save
         ST    R3,SAVER3E             registers.
         USING CHAIN,R3
FORCANC0 DS    0H                  Show cancelable or not.
         TM    SAVEACTF,CHCL       Is job cancelable?
         BO    FORCANC1            Yes, show cancelable.
         BZ    FORCANC2            No. Show non-cancelable.
         B     FORFORC0            Fall through, try forceable.
FORCANC1 DS    0H
         MVC   MESSTXT,MESSCAN     Tell em job is cancelable.
         B     FORCANCP
FORCANC2 DS    0H
         MVC   MESSTXT,MESSNCN     Tell em job is non-cancelable.
FORCANCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORFORC0 DS    0H                  Show forceable or not.
         TM    SAVEACTF,CHAFORCE   Can you do FORCE w/o CANCEL?
         BO    FORFORC1            Yes. Don't need CANCEL first.
         BZ    FORFORC2            No. Show you need CANCEL first.
FORFORC1 DS    0H
         MVC   MESSTXT,MESSFOR     Tell em FORCE ok w/o CANCEL.
         B     FORFORCP
FORFORC2 DS    0H
         MVC   MESSTXT,MESSNFR     Tell em need CANCEL before FORCE.
FORFORCP DS    0H                  Write the actual message out.
         MVC   OUTPUT,OUTPUT-1
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
FORKILLF DS    0H                  Figure out if Non-Memtermable or not
         ST    R4,SAVER4D          Save work register
*        CLC   SAVEASID,CHASID
*        BNE   FORKILLX
*        MVC   FOUNASID,CHASID     Stage ASID for GETASCB routine
*        B     FORKILLY
FORKILLX MVC   FOUNASID,SAVEASID
FORKILLY DS    0H
         BAL   R9,GETASCB          Get the ASCB.
         LTR   R15,R15             Is there one?
         BZ    FORCHEND            No. Exit this routine.
         ST    R15,SAVEASCB        Save address of ASCB.
         L     R4,SAVEASCB         Reload address of ASCB in work reg.
         L     R4,0(,R4)           Get actual ASCB into register.
         USING ASCB,R4
         TM    ASCBFLG2,ASCBNOMT   Test if Non-Memtermable bit is on.
         BZ    FOROMEMT            No. Report that it's off.
         MVC   MESSTXT,MESSNMT     Yes. Put Non-Memtermable into msg.
         B     FORKILLO            And put out the message.
FOROMEMT DS    0H
         MVC   MESSTXT,MESSMMT     No. Put Memtermable into message.
FORKILLO MVC   OUTPUT,OUTPUT-1     And put out the message.
         MVC   OUTPUT(28),FORMTMSG
         APUT  OUTPUT,30
         L     R4,SAVER4D          Restore work register.
         DROP  R4                  Lose ASCB addressability.
FORCHEND DS    0H
         DROP  R3
         L     R3,SAVER3E          Restore
         L     R9,SAVER9J             registers.
         BR    R9
*            Constants associated with this routine.    -    below
MESSCAN  DC    CL15'Cancelable     '
MESSNCN  DC    CL15'Non-Cancelable '
MESSFOR  DC    CL15'Force w/o Cncel'
MESSNFR  DC    CL15'Cancel + Force '
MESSNMT  DC    CL15'Non-Memtermable'
MESSMMT  DC    CL15'Memtermable    '
FORMTMSG DS    0CL28
MESS000  DC    CL13'Job Status:  '
MESSTXT  DC    CL15'               '
*            Constants associated with this routine.    -    above
** ---------------------------------------------------------------- **
PRINTERR DS    0H                    Print help messages.
         ST    R9,SAVER9K            Save BAL register.
         APUT  MESSAG2A,L'MESSAG2A
         APUT  MESSAG2B,L'MESSAG2B
         APUT  MESSAG2C,L'MESSAG2C
         APUT  MESSAG2D,L'MESSAG2D
         APUT  MESSAG2V,L'MESSAG2V
         APUT  MESSAG2E,L'MESSAG2E
         APUT  MESSAG2F,L'MESSAG2F
         APUT  MESSAG2Z,L'MESSAG2Z
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2G,L'MESSAG2G
         APUT  MESSAG2H,L'MESSAG2H
         APUT  MESSAGEM,L'MESSAGEM
         APUT  MESSAG2I,L'MESSAG2I
         APUT  MESSAG2J,L'MESSAG2J
         APUT  MESSAG2K,L'MESSAG2K
         APUT  MESSAG2L,L'MESSAG2L
         APUT  MESSAG2M,L'MESSAG2M
         APUT  MESSAG2N,L'MESSAG2N
         APUT  MESSAG2O,L'MESSAG2O
         APUT  MESSAG2P,L'MESSAG2P
         APUT  MESSAG2Q,L'MESSAG2Q
         APUT  MESSAG2R,L'MESSAG2R
         APUT  MESSAG2S,L'MESSAG2S
         APUT  MESSAG2T,L'MESSAG2T
         APUT  MESSAGEM,L'MESSAGEM
         L     R9,SAVER9K            Restore BAL register.
         BR    R9
** ----------------------------------------------------------------- **
*        Control of the following routines are under control of       *
*           the KILLFLAG, and are not under control of FLAG2.         *
*                                                                     *
*        KILLFLAG controls processes KILL, BURN, NMEM and MEMT.       *
*              (Routine sets FLAG2 EQU X'80')                         *
*  ------------------------------------------------------------------ *
*                   Settings of the KILLFLAG                          *
*                                                                     *
*  KILLFLAG  equals  X'01'            for KILL (whack always)         *
*                    X'01' and X'02'  for BURN (whack only if MEMT)   *
*                    X'04'            for NMEM (make NON-memtermable) *
*                    X'08'            for MEMT (make memtermable)     *
*                                                                     *
** ----------------------------------------------------------------- **
DONMEM   DS    0H                        NON-MEMTERMABLE   FLAG X'04'
         NI    KILLFLAG,X'04'            ONLY NMEM FLAG ON. Others off
         OI    KILLFLAG,X'04'            TURN NMEM FLAG ON
         B     FLGSDONE
DOMEMT   DS    0H                        MEMTERMABLE       FLAG X'08'
         NI    KILLFLAG,X'08'            ONLY MEMT FLAG ON  Others off
         OI    KILLFLAG,X'08'            TURN MEMT FLAG ON
         B     FLGSDONE
DOBURN   DS    0H                        BURN. X'02' and X'01' both on
         OI    KILLFLAG,X'02'            Announce BURN as keyword
DOKILL   DS    0H                        KILL process. KILL flag on.
         OI    KILLFLAG,X'01'            Announce KILL as keyword
FLGSDONE DS    0H                        Flags have been set.
         TM    FLAG0,X'40'               Have PSCB ACCT authority?
         BZ    NOTALLOW                  No. Can't do these commands.
*  ------------------------------------------------------------------ *
*                    Print the action code for                        *
*                    everything under FLAG2=X'80'                     *
*  ------------------------------------------------------------------ *
         OI    FLAG2,X'80'               Mark under KILLFLAG control.
*  ------------------------------------------------------------------ *
         MVC   OUTPUT,OUTPUT-1           Print message accordingly
         MVC   OUTPUT(15),=C'Action code   :'
TRYBURN  TM    KILLFLAG,X'02'            For BURN, X'01' and X'02' on.
         BZ    TRYKILL
         MVC   OUTPUT+17(4),BURNC        Mark as a BURN.
         B     PRTCODE
TRYKILL  TM    KILLFLAG,X'01'
         BZ    TRYNMEM
         MVC   OUTPUT+17(4),KILLC        Mark as a KILL.
         B     PRTCODE
TRYNMEM  TM    KILLFLAG,X'04'
         BZ    TRYMEMT
         MVC   OUTPUT+17(4),NMEMC        Mark as a NMEM.
         B     PRTCODE
TRYMEMT  TM    KILLFLAG,X'08'
         BZ    PRTCODE
         MVC   OUTPUT+17(4),MEMTC        Mark as a MEMT.
PRTCODE  DS     0H                       And print the result.
         APUT  OUTPUT,25
*  ------------------------------------------------------------------ *
* -- >  Test if this command is being run APF Authorized - below    BUR
TAUTH    STM   R15,R1,SAVE14T1   Now save registers and test if APF BUR
         XR    R15,R15                authorized.                   BUR
         TESTAUTH FCTN=1           Are we authorized?               BUR
         LTR   R15,R15             Test the return code.            BUR
         BNZ   NOTAUTH           Not zero, tell not authorized.     BUR
         LM    R15,R1,SAVE14T1   Restore registers used by TESTAUTH BUR
* -- >  Test if this command is being run APF Authorized - above    BUR
*  ------------------------------------------------------------------ *
         BAL   R9,FINDCSCB               Get correct CSCB entry.    BUR
         MODESET KEY=ZERO,MODE=SUP                                  BUR
         ST    R7,SAVER7B                Store work register        BUR
         LH    R7,CSCBASID               Set ASID                   BUR
         TM    KILLFLAG,X'0C'            NMEM or MEMT action?
         BNZ   ASCBBITS                  If either, then not KILL
*----->               KILL routine - below                          KIL
         TM    KILLFLAG,X'01'            Is the KILL flag on?       KIL
         BZ    SKIPMEMT                  No. Exit this routine.     KIL
ASCBBITS DS    0H
         CLC   CSCBASID,=X'0000'         Did FINDCSCB find a CSCB?  KIL
         BE    SKIPMEMT                  No. Exit this routine.     KIL
         MVC   FOUNASID,CSCBASID         Stage ASID to get the ASCB KIL
         BAL   R9,GETASCB                Get the ASCB.              KIL
         LTR   R15,R15                   Is there one?              KIL
         BZ    SKIPMEMT                  No. Exit this routine.     KIL
         ST    R15,SAVEASCB              Save address of ASCB.      KIL
         L     R15,0(,R15)               Load it to address fields. KIL
         USING ASCB,R15                                             KIL
         TM    KILLFLAG,X'08'            MEMT?
         BO    FORCEOFF
         TM    KILLFLAG,X'04'            NMEM?
         BO    FORCEON
         TM    KILLFLAG,X'02'            BURN only?                 BUR
         BO    EXITKILL                  Non-forcible still on.     BUR
         TM    KILLFLAG,X'01'            If not X'01' then no MEMTERM.
         BZ    SKIPMEMT                  Yes. Turn off ASCB bits first.
         NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit  KIL
         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit     KIL
         B     EXITKILL                  Go do MEMTERM.
FORCEOFF NI    ASCBFLG2,255-ASCBNOMT     Turn off NON-FORCIBLE bit
         NI    ASCBFLG2,255-ASCBNOMD     Turn off Dat error bit
         B     SKIPMEMT                  And skip MEMTERM.
FORCEON  DS    0H                        Make Non-Memtermable.
         OI    ASCBFLG2,ASCBNOMT         Put the ASCBNOMT bit on.
         ST    R3,SAVER3F                Then
         L     R3,FOUNCSCB                  Make
         USING CHAIN,R3                        Job
         NI    CHACT,255-X'08'                    Non-Cancelable too.
         MVC   SAVEACTF(1),CHACT         Save for reporting
         L     R3,SAVER3F                Restore work register.
         B     SKIPMEMT                  Don't do CALLRTM MEMTERM.
         DROP  R3
EXITKILL DS    0H                        Now do CALLRTM MEMTERM.    KIL
         DROP  R15                       Drop ASCB addressability   KIL
*----->               KILL routine - above                          KIL
         ST    R13,SAVER13A              Save R13                   BUR
         LA    R13,RTMSAVE               RTM save area              BUR
         CALLRTM TYPE=MEMTERM,ASID=(R7),COMPCOD=100                 BUR
         STC   R15,RTMCOD                Save MEMTERM Return Code
         L     R13,SAVER13A              Restore R13                BUR
SKIPMEMT DS    0H
         L     R7,SAVER7B                Restore work register      BUR
         MODESET KEY=NZERO,MODE=PROB                                BUR
         CLI   RTMCOD,X'2C'              Non-memtermable addr space?
         BE    NOTMEMTM                  Yes. Issue message to say so.
*
         TM    KILLFLAG,X'04'            Message if NMEM done.
         BZ    TRYMMEMT
         MVC   MESSAGM1+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGM1+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGM1,L'MESSAGM1       Say job made non-memtermable
         B     BURNEND                   Done with message
TRYMMEMT DS    0H
         TM    KILLFLAG,X'08'
         BZ    TRYMBURN
         MVC   MESSAGM2+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGM2+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGM2,L'MESSAGM2       Say job was killed.        BUR
         B     BURNEND                   Done with message          KIL
TRYMBURN TM    KILLFLAG,X'02'            KILL msg instead of BURN?  KIL
         BO    BURNMSG                   Yes. Run BURN message.     KIL
         MVC   MESSAGKI+4(8),FOUNJOBI    Jobname into message       BUR
         HEX   MESSAGKI+22,2,FOUNASID    ASID into message          BUR
         APUT  MESSAGKI,L'MESSAGKI       Say job was burned.        BUR
         B     BURNEND                   Skip BURN message          KIL
BURNMSG  DS    0H
         MVC   MESSAGBU+4(8),FOUNJOBI    Jobname into message       KIL
         HEX   MESSAGBU+22,2,FOUNASID    ASID into message          KIL
         APUT  MESSAGBU,L'MESSAGBU       Say job was burned.        KIL
BURNEND  DS    0H
         B     GETIDEND            After enough looks, end.         KIL
RTMSAVE  DS    CL72                Work area for RTM                BUR
SAVER13A DS    F                   Place to save R13                BUR
SAVEASCB DS    F                   Save ASCB address                KIL
** ---------------------------------------------------------------- **
KEY0SWNS DS    0H                    Key 0 for SWAP or NSWP
         ST    R9,SAVER9L            Save BAL register.
         ST    R6,SAVER6A
KEY0TSTA DS    0H
* -- >  Test if this command is being run APF Authorized - below
         STM   R15,R1,SAVE14T1     Now save registers and test if APF
         XR    R15,R15                  authorized.
         TESTAUTH FCTN=1           Are we authorized?
         LTR   R15,R15             Test the return code.
         BNZ   NOTAUTH             Not zero, tell not authorized.
         LM    R15,R1,SAVE14T1     Restore registers used by TESTAUTH.
* -- >  Test if this command is being run APF Authorized - above
         TM    FLAG2,X'04'         Make ASID swappable?
         BO    KEY0SWAP            Yes. Do it.
         TM    FLAG2,X'08'         Make ASID non-swappable?
         BO    KEY0NSWP            Yes. Do it.
         B     KEY0EXIT            Not SWAP or NSWP, don't belong here.
*
KEY0NSWP DS    0H                    Make address space non-swappable.

         CLC   OWNASID,FOUNASID      Target asid different from ours?
         BE    KEY0DNSW              No. Just do SYSEVENT.
         MVC   FUNC,=CL8'DONTSWAP'   Set nswapping function
         BAL   R9,BUILDSRB           Build SRB block
*
* ISSUE SUCCESSFUL MESSAGE
*
         MVC   MESSAGNS+4(8),FOUNJOBI
         HEX   MESSAGNS+22,2,FOUNASID
         APUT  MESSAGNS,L'MESSAGNS
         L     R6,SAVER6A            Restore Register
         L     R9,SAVER9L            Restore BAL register.
         BR    R9                    go back
TEMPSAVE DS    4F                    save area
* - cross address space stuff - above
KEY0DNSW DS    0H
         MODESET MODE=SUP,KEY=ZERO
KEY0SYSD DS    0H
         LH    R6,FOUNASID
         SYSEVENT DONTSWAP,ASID=(R6),ENTRY=SVC
*        STATUS SET,MC,STEP                  EXCLUSIVE TASK
*        LA    R1,1                          LOAD NEW AUTH. INDEX
*        AXSET AX=(1)                        SET NEW AUTH. INDEX
*        ST    R0,OLDAX                      SAVE OLD AUTH. INDEX
*        LH    R1,FOUNASID                   LOAD JES2 ASID.
*        SSAR  R1                            SET SPACE SECONDARY JES2.
*        ST    R1,SYSEVCOD
*        LTR   R1,R1
*        BNZ   KEY0NODO
*        STATUS RESET,MC,STEP
KEY0NNRM DS    0H
         MODESET MODE=PROB,KEY=NZERO
         MVC   MESSAGNS+4(8),FOUNJOBI
         HEX   MESSAGNS+22,2,FOUNASID
         APUT  MESSAGNS,L'MESSAGNS
         B     KEY0EXIT
KEY0SWAP DS    0H                    Make address space swappable.
         CLC   OWNASID,FOUNASID      Target asid different from ours?
         BE    KEY0DSWP              No. Just do SYSEVENT.
         MVC   FUNC,=CL8'OKSWAP'     Set function
         BAL   R9,BUILDSRB           Build SRB CSA CONTROL BLOCKS
*
*  issue successful message
*
         MVC   MESSAGSW+4(8),FOUNJOBI
         HEX   MESSAGSW+22,2,FOUNASID
         APUT  MESSAGSW,L'MESSAGSW
         L     R6,SAVER6A            Restore Registers
         L     R9,SAVER9L            Restore BAL register.
         BR    R9
* - cross address space stuff - below
* - cross address space stuff - above
KEY0DSWP DS    0H
         LH    R6,FOUNASID
         SYSEVENT OKSWAP,ASID=(R6),ENTRY=SVC
*        STATUS RESET,MC,STEP
*        ST    R1,SYSEVCOD
*        LTR   R1,R1
*        BNZ   KEY0NODO
KEY0SNRM DS    0H
         MODESET MODE=PROB,KEY=NZERO
         MVC   MESSAGSW+4(8),FOUNJOBI
         HEX   MESSAGSW+22,2,FOUNASID
         APUT  MESSAGSW,L'MESSAGSW
         B     KEY0EXIT
KEY0NODO DS    0H
         MODESET MODE=PROB,KEY=NZERO
         HEX   MESSAGNG+43,1,SYSEVCOD+3
         APUT  MESSAGNG,L'MESSAGNG
KEY0EXIT DS    0H
         L     R6,SAVER6A
         L     R9,SAVER9L            Restore BAL register.
         BR    R9
*--------------------------------------------------------------*
*                                                              *
*        build srb control block and accompanying code         *
*--------------------------------------------------------------*
BUILDSRB DS    0H
         STM   R6,R9,TEMPSAVE        Save Registers
         BAL   R9,GETASCB            Find ASCB for this asid
         LR    R9,R15                Hold ASCB
         L     R9,0(,R9)             Point to ASCB
         MODESET MODE=SUP,KEY=ZERO   Get into supervisor state
*
CSA_LEN  EQU  SRBSIZE+84             Csa SRBLOCK AND PARAMTERS
*
*---------------------------------------------------------------*
*       Get CSA for SRB CONTROL BLOCK SUBPOOL 241               *
*---------------------------------------------------------------*
         STORAGE OBTAIN,SP=241,LENGTH=CSA_LEN Get Some CSA
         LR    R6,R1                 Point r2 to srb control block
         USING SRB,R6                Address SRB
         XC    SRB(SRBSIZE),SRB      Clear out srb
         ST    R9,SRBASCB            Save ASCB
         LA    R8,SRBSIZE(,R6)       R8 -> paramlist
*       Get CSA paramter list                                   *
         ST    R8,SRBPARM            Store paramter list address
         LA    R7,72(,R8)            Point to ECB
         XC    0(4,R7),0(R7)         Clear ECB Address
         LA    R7,4(,R7)             Point to ASCb
         MVC   0(4,R7),X'224'        Move "HOME" PSAAOLD address sp
         LA    R7,4(,R7)             bump to next param
         CLC   FUNC,=C'DONTSWAP'     Q. non swappable function
         BE    NONSWAP               yes; branch if so
         MVC   0(4,R7),=C'OKSW'      otherwise swappable
         B     SETEPA                set srb program entry point
NONSWAP  DS    0H
         MVC   0(4,R7),=C'DONT'      Set FUNCTION IN R7
*---------------------------------------------------------------*
*       Get CSA for SRB CONTROL BLOCK SUBPOOL 227               *
*---------------------------------------------------------------*
SETEPA   DS    0H
         STORAGE OBTAIN,SP=227,LENGTH=SWAPLEN  Get Fixed CSA
         ST    R1,SRBEPA             set entry point
         LR    R14,R1                Hold that thought
         LA    R15,SWAPLEN           Get Length
         LR    R1,R15
         LA    R0,SWAPXMEM           Point to SRB routine
         MVCL  R14,R0                Move routine
*
         SCHEDULE SRB=(R6),SCOPE=GLOBAL,MODE=NONXM
*
         LA    R7,72(,R8)            Point to ECB
*
         WAIT  ECB=(R7)
*
         L     R9,SRBEPA             Get Entry Point Address
*
         STORAGE RELEASE,ADDR=(R6),LENGTH=CSA_LEN,SP=241
*
         STORAGE RELEASE,ADDR=(R9),LENGTH=SWAPLEN,SP=227
*
         MODESET KEY=NZERO,MODE=PROB
*
         LM    R6,R9,TEMPSAVE        Save Registers
         BR    R9                    Return
SYSEVCOD DC    F'0'                  SYSEVENT Return Code
OLDAX    DS    F
WAREA    DS    D                     Work area
WAREB    DS    D                     Work area
** ---------------------------------------------------------------- **
** --         C  O  N  S  T  A  N  T  S                          -- **
** ---------------------------------------------------------------- **
MESSAGNA DC    C'Command was not invoked APF authorized.'
MESSAGEN DC    C'End of CSCB chain was reached.'
MESSAGEY DC    C'No valid keyword was coded.'
FLAG0    DC    X'00'               Copy of PSCBATR1 - Authority levels
FLAG1    DC    X'00'               Needed to parse parameters
*              X'01'               ASID ONLY - NO JOBNAME
*              X'02'               JOBNAME IS PRESENT.
*              X'04'               ASID( WAS PRESENT IN PARMS.
*              X'08'               CSCB CHAIN DISPLAY ONLY.
FLAG2    DC    X'00'
*              X'01'               CNCL WAS CODED
*              X'02'               NCNC WAS CODED
*              X'04'               SWAP WAS CODED
*              X'08'               NSWP WAS CODED
*              X'10'               FORC WAS CODED
*              X'20'               CSCB WAS CODED
*              X'80'               BURN or KILL was coded           BUR
*              X'40'               CSCB chain run only.
FLAG3    DC    X'00'
RTMCOD   DC    X'00'               Saved return code from MEMTERM
ONSWIT   DC    X'00'
*              X'01'               TURN BIT ON
*              X'02'               TURN BIT OFF
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
SAVE     DS    9D                  Program Save Area
SAVE14T1 DS    2D                  Save "system-used" registers.
         DC    C' '                Blank before OUTPUT line.
OUTPUT   DC    CL80'  '            Variable output line.
FUNC     DS    CL8                 Swapppinmg function
         LTORG
*-----------------------------------------------------------------*
*                         SRB CODE                                *
*-----------------------------------------------------------------*
SWAPXMEM DS    0D
         DROP  R12,R11,R10
         BASR  R5,0
         USING *,R5                  Entry Point
         LR    R10,R14               SAVE RETURN ADDRESS
         LR    R13,R1
*
         LA    R9,72(,R13)          Point to ECB Address
         LA    R8,76(,R13)          Point to ASCB Address
         L     R8,0(,R8)
         L     R7,80(,R13)          Get code
*
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=STDSAVE
*
         C      R7,=C'OKSW'        OKSWAP
         BE     SETSWAP
*
         XR    R1,R1               Undocumented instead of WAIT
         SYSEVENT DONTSWAP,ENTRY=BRANCH
*
         B     UNLOCK
*
SETSWAP  DS    0H
         XR    R1,R1               Undocumented instead of WAIT
         SYSEVENT OKSWAP,ENTRY=BRANCH
*
UNLOCK   DS    0H
         SETLOCK RELEASE,TYPE=LOCAL,REGS=STDSAVE
*
*
         POST  (R9),ASCB=(R8),ERRET=GOBACK,LINKAGE=BRANCH
*
GOBACK   LR    R14,R10               Return Address
         BR    R14                   Return
         LTORG
SWAPRTM  DS    0D
SWAPLEN  EQU   *-SWAPXMEM
** ---------------------------------------------------------------- **
ACEECSEC CSECT
ACEECOPY DC    XL192'00'
ACEEADDR DC    F'0'
ACEECLEN EQU   *-ACEECSEC
** ---------------------------------------------------------------- **
CNCLPG   CSECT
         IHAACEE
         SPACE
         TITLE '- MAPPING MACROS.'
         CVT   DSECT=YES           Map the CVT.
         IEECHAIN                  Map the CSCB control block.
         IHASRB
         IHAASVT
         IHAASCB
         IHAASXB
         IRAOUCB
         IHAPSA   DSECT=YES,LIST=YES                           HD APR88
         IHAFRRS
         EJECT                                                 HD APR88
         IKJEFLWA
         END   CNCLPG
** ---------------------------------------------------------------- **
*  -----------------------------------------------------------------  *
*  --           Create PUTLINE environment.                       --  *
*  -----------------------------------------------------------------  *
EPUTL    TITLE 'PUTLINE FOR FEWER THAN 83 ARGUMENTS IN THE KEY OF C MAJ&
               OR'
EPUTL    CSECT                                              *HMD 10/85*
         LCLB  &XA                                          *HMD 10/85*
&XA      SETB  1                  SET TO ZERO ON NON/XA     *HMD 10/85*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*  MODULE NAME  . . . . EPUTL
*
*  ALIASES  . . . . . . NONE
*
*  DATE WRITTEN . . . . 06/85
*  UPDATED      . . . . 04/88                                  HD APR88
*
*  AUTHOR . . . . . . . JIM ELSWORTH
*  UPDATOR  . . . . . . HOWARD M. DEAN                         HD APR88
*
*  ENVIRONMENT  . . . . TSO COMMAND-PROCESSOR
*
*  PURPOSE:
*    ALLOW AN EASY INTERFACE TO PUTLINE ROUTINE
*
*
*  DESCRIPTION:
*    BUILDS PUTLINE PARAMETER LIST BASED ON INPUT ARGUMENTS.
*    ISSUES SINGLE LINE PUTLINE.
*
*
*  ATTRIBUTES:
*    REENTRANT
*
*  FEATURES:
*    WILL RUN UNDER BATCH TMP SINCE PUTLINE USED INSTEAD OF TPUT.
*
*  CALLED MODULES:
*    PUTLINE
*
*  ASSUMPTIONS:
*    CALLED BY A TSO-CP THAT IS OBSERVING STANDARD LINKAGE
*
*  ABENDS:
*    POSSIBLE 0CX IF BAD ARGUEMNTS
*
*  CAVEATS:
*    UNPREDICTABLE RESULTS IF FIRST PROGRAM RUNNING UNDER THIS TCB
*    DID NOT SAVE (14,12) BEFOR R1 WAS MODIFIED.
*
*
*  INPUT ARGUMENTS:
*    1)  R1 : ADDRESS OF MESSAGE TEXT
*    2)  R0 : LENGTH OF MESSAGE TEXT
*    3) R13 : STANDARD OS SAVE AREA
*    4) R14 : RETURN ADDRESS
*    5) R15 : ENTRY ADDRESS
*
*               ( CONTINUED ... )
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*  OUTPUT ARGUMENT: RETURN CODE FROM PUTLINE OR
*
RCBA     EQU   100                 BAD MESSAGE ADDRESS
RCBL     EQU   104                 MESSAGE LENGTH <1 OR >MAXMSG
*
MAXMSG   EQU   128                 MAXIMUM MESSAGE LENGTH
*
*
*  REGISTERS USED:
*
R0       EQU   0                   MESSAGE LENGTH AT ENTRY
R1       EQU   1                   MESSAGE ADDRESS AT ENTRY
R2       EQU   2                   WORK
RMA      EQU   4                   @MESSAGE TEXT
RML      EQU   5                   MESSAGE LENGTH
RUPT     EQU   6                   @UPT (USER PROFILE TABLE)
RECT     EQU   7                   @ECT
R12      EQU   12                  CSECT BASE
R13      EQU   13                  @SAVE AREA AND DYNAMIC WORK AREA
R14      EQU   14                  WORK/LINKAGE
R15      EQU   15                  WORK/LINKAGE
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
         IKJCPPL
         EJECT
         IKJTCB   LIST=YES                                  *HMD 10/85*
         EJECT                                              *HMD 10/85*
         CVT      DSECT=YES,LIST=YES                        *HMD 10/85*
         IHAPSA   DSECT=YES,LIST=YES                           HD APR88
         EJECT
PUTLDS   DSECT
         DS    18F                      OS SAVE AREA
PUTAAA   EQU   *
PUTECB   DS    F                        ECB
PUTIOPL  DS    4F                       IOPLADS
PUTBLOK  PUTLINE MF=L
PUTLEN   DS    H                        LENGTH
PUTZZZ   DS    H                        RESERVED
PUTMSG   DS    (MAXMSG)C                MESSAGE TEXT AREA
PUTSIZE  EQU   *-PUTLDS                 SIZE OF PUTLINE PARMS
         EJECT
***********************************************************************
*  SET UP LINKAGE
***********************************************************************
         SPACE 1
EPUTL    CSECT
         AIF  (NOT &XA).X001                                *HMD 10/85*
EPUTL    AMODE 31
.X001    ANOP                                               *HMD 10/85*
         STM   14,12,12(13)       SAVE CALLERS REGS
         LR    R12,R15            COPY EPA
         USING EPUTL,R12          ADDRESSABILITY
         AIF   (NOT &XA).X002                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE,        STANDARD OS SA PLUS ANY EXTRA        &
               LOC=RES            RELATIVE TO 16MB LINE
         AGO   .X003                                        *HMD 10/85*
.X002    ANOP                                               *HMD 10/85*
         GETMAIN RU,              LV=LENGTH                            &
               LV=PUTSIZE         STANDARD OS SA PLUS ANY EXTRA
.X003    ANOP                                               *HMD 10/85*
         ST    1,8(13)            OUR SAVE AREA POINTER
         ST    13,4(1)            POINTER TO CALLERS SAVE AREA
         LR    13,1               @OUR SAVE AREA
         USING PUTLDS,R13         MAP SA AND WORK AREA
         L     R14,4(R13)         POINT TO CALLERS RSA
         LM    R0,R1,20(R14)      RESTORE REGS CHANGED BY GETMAIN
         SPACE 2
***********************************************************************
*  UNLOAD ARGUMENTS AND VALIDATE WHERE POSSIBLE
***********************************************************************
         SPACE 1
         LA    R15,RCBA                 ASSUME BAD ADDRESS
         LTR   RMA,R1                   MESSAGE ADDRESS
         BNP   RETURN                   GOOD ASSUMPTION
         LA    R15,RCBL                 ASSUME BAD LENGTH
         LTR   RML,R0                   POSITIVE?
         BNP   RETURN                   -NO
         C     RML,=A(MAXMSG)           MORE THAN MAX?
         BH    RETURN                   -YES
         SPACE 2
***********************************************************************
*  BUILD PARAMETER LIST
***********************************************************************
         SPACE 1
         LA    R15,4(RML)               MESSAGE LENGTH
         STH   R15,PUTLEN                 PLUS HEADER
         XC    PUTZZZ,PUTZZZ            CLEAR 2ND HWORD OF RDW
         BCTR  RML,0                    REDUCE FOR MOVE
         EX    RML,PUTMOVE
         EJECT
***********************************************************************
*  DIG UP ADDRESS OF UPT AND ECT
***********************************************************************
         SPACE 1
         L     R2,PSATOLD-PSA           @TCB                   HD APR88
         L     R2,TCBFSA-TCB(R2)        @1ST PROBLEM PGM SAVE AREA
         L     R2,24(R2)                REG1 THAT WAS PASSED TO CP
         USING CPPL,R2                  MAP CPPL
         L     RUPT,CPPLUPT             @UPT
         L     RECT,CPPLECT             @ECT
         SPACE 2
***********************************************************************
*  ISSUE PUTLINE CALL
***********************************************************************
         SPACE 1
         XC    PUTECB,PUTECB            CLEAR ECB
         XC    PUTBLOK(12),PUTBLOK      CLEAR PARM BLOCK       HD APR88
         PUTLINE PARM=PUTBLOK,          PARAMETER BLOCK                &
               UPT=(RUPT),              @UPT                           &
               ECT=(RECT),              @ECT                           &
               ECB=PUTECB,              @ECB                           &
               OUTPUT=(PUTLEN,TERM,SINGLE,DATA),                       &
               MF=(E,PUTIOPL)
         EJECT
***********************************************************************
*  RETURN TO CALLER
***********************************************************************
         SPACE 1
RETURN   EQU   *
         LR    2,R13                    @OUR SAVE AREA
         LR    3,R15                    SAVE RETURN CODE
         L     R13,4(R13)               @CALLERS SAVE AREA
         FREEMAIN RU,LV=PUTSIZE,A=(R2),SP=0
         LR    R15,3                    RESTORE RC
         RETURN (14,12),RC=(15)         RESTORE CALLERS REGS
         SPACE 5
***********************************************************************
*  CONSTANTS AND NON-REENTRANT WORK AREAS
***********************************************************************
         SPACE 1
PUTMOVE  MVC   PUTMSG(*-*),0(RMA)       MOVE MESSAGE TO BUFFER
         SPACE 2
         LTORG
         SPACE 2
         END EPUTL
FACEE    TITLE 'FACEE - DUMP CONTENTS OF THE ACEE'
         SPACE 1
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  DOCUMENTATION:   THIS PROGRAM IS THE CALLABLE VERSION OF DACEE,    *
*                   TO FORMAT AN ACEE IMAGE.                          *
*                                                                     *
*         SYNTAX:   EXPECTED IS R1 POINTING TO THE ACEECSEC CSECT     *
*                                                                     *
*                   ACEECSEC CSECT                                    *
*                   ACEECOPY DC    XL192'00'    ACEE image to format  *
*                   ACEEADDR DC    F'0'         Its original address  *
*                   ACEECLEN EQU   *-ACEECSEC                         *
*                                                                     *
*                   CALL FACEE WITH R1 POINTING TO 192-BYTE AREA      *
*                   CONTAINING THE IMAGE OF AN ACEE CONTROL BLOCK,    *
*                   AS PART OF THE ACEECSEC CONTROL BLOCK.            *
*                                                                     *
*       FUNCTION:   SHOW CONTENTS OF MANY ACEE FIELDS AND HEX DUMP    *
*                   THE ENTIRE CONTROL BLOCK.                         *
*                                                                     *
*                   PUTLINE TERMINAL INTERFACE ALLOWS THE             *
*                   TRAPPING OF OUTPUT.  NO APF AUTHORIZATION         *
*                   REQUIRED, JUST FOR THE FORMATTING, BUT SINCE      *
*                   OBTAINING THE CROSS-MEMORY ACEE REQUIRES          *
*                   AUTHORIZATION, YOU NEED AC(1) IN THAT CASE.       *
*                                                                     *
*    SAMPLE CALL:                                                     *
*                                                                     *
*             L     R15,SAVFACEE  Load entry pt of FACEE program.     *
*             XR    R1,R1         Clear R1 to be sure.                *
*             L     R1,SAVACEEC   Load address of ACEE image CSECT.   *
*             BALR  R14,R15       Call FACEE to display the data.     *
*                                                                     *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* ------------------------------------------------------------------- *
         MACRO
&LABEL   APUT  &MSG,                    @MESSAGE TEXT                  &
               &LEN,                    @LENGTH OF MESSAGE             &
               &RSA=,                   OPTIONAL 2 WORD SAVE AREA      &
               &EPA=                    EPUTL EPA
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*  --> E@PUT
.*
.*  THIS MACRO SETS UP A PARAMETERS AND INVOKES THE EPUTL ROUTINE.
.*
.*
.*  ARGUMENTS: -----------------------------------------------------
.*
.*      &MSG : ADDRESS OF MESSAGE TEXT OR A LITERAL
.*
.*      &LEN : LENGTH OF MESSAGE TEXT (DEFAULT IS L'&MSG)
.*
.*      &RSA :(OPTIONAL) 1 WORD SAVE AREA TO PRESERVE R14 FOR TPUT
.*            COMPATIBILITY.
.*
.*      &EPA :(OPTIONAL) EPA FOR EPUTL ROUTINE
.*
.*
.*   EXAMPLES: -----------------------------------------------------
.*
.*      1) APUT  'LITERAL'
.*
.*      2) APUT  (R3),80
.*
.*      3) APUT  LABEL
.*
.*      4) APUT  LABEL,40
.*
.*
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*
.*
.*  LOCAL SET SYMBOLS
.*
         LCLC  &SMA                     MESSAGE ADDRESS (REG)
         LCLC  &SML                     MESSAGE LENGTH (REG)
         LCLC  &SEP                     EPA (REGISTER)
.*
         LCLC  &L1,&L2,&L3              LOCAL LABELS
.*
&L1      SETC  'EP'.'&SYSNDX'.'L1'      LOCAL LABELS
&L2      SETC  'EP'.'&SYSNDX'.'L2'      LOCAL LABELS
&L3      SETC  'EP'.'&SYSNDX'.'L3'      LOCAL LABELS
.*
.*
.*  MESSAGE ADDRESS
.*
         AIF   (T'&LABEL EQ 'O').A0500                      *HMD 11/86*
.*                                                          *HMD 11/86*
&LABEL   DS    0H                                           *HMD 11/86*
.*                                                          *HMD 11/86*
.A0500   ANOP                                               *HMD 11/86*
         AIF   ('&MSG' NE '').A2000
         MNOTE 8,'''&MSG='' MISSING / REQUIRED'
         MEXIT
.*
.A2000   ANOP
         AIF   ('&MSG'(1,1) NE '(').A2400
&SMA     SETC  '&MSG'(2,K'&MSG-2)
         LR    R1,&SMA                  @MESSAGE TEXT
         AGO   .A2600
.*
.A2400   ANOP
         AIF   ('&MSG'(1,1) NE '''').A2500
         B     &L3                      BRANCH AROUND MESSAGE
&L2      DC    C&MSG
&L3      DS    0H
         LA    R1,&L2                   @MESSAGE
         AGO   .A2600
.*
.A2500   ANOP
         LA    R1,&MSG                  @MESSAGE TEXT
.A2600   ANOP
.*
.*  MESSAGE LENGTH
.*
         AIF   ('&LEN' NE '').A3000
         AIF   ('&MSG'(1,1) NE '''').A2800
         LA    R0,L'&L2                 MESSAGE LENGTH
         AGO   .A3600
.*
.A2800   ANOP
         AIF   ('&MSG'(1,1) EQ '(').A2900
         LA    R0,L'&MSG                MESSAGE LENGTH
         AGO   .A3600
.*
.A2900   ANOP
         MNOTE 8,'''LEN'' MISSING / REQUIRED'
         MEXIT
.*
.A3000   ANOP
         AIF   ('&LEN'(1,1) NE '(').A3400
&SML     SETC  '&LEN'(2,K'&LEN-2)
         LR    R0,&SML                  MESSAGE LENGTH
         AGO   .A3600
.*
.A3400   ANOP
         LA    R0,&LEN                  MESSAGE LENGTH
.A3600   ANOP
.*
.*  RSA
.*
         AIF   ('&RSA' EQ '').A4900
         ST    R14,&RSA                 SAVE REGS 14
.A4900   ANOP
.*
.*  ENTRY POINT
.*
         AIF   ('&EPA' NE '').A5000
         L     R15,=V(EPUTL)            EPA
         AGO   .A5600
.*
.A5000   AIF   ('&EPA'(1,1) NE '(').A5400
&SEP     SETC  '&EPA'(2,K'&EPA-2)
         LR    R15,&SEP                 EPA
         AGO   .A5600
.*
.A5400   ANOP
         L     R15,&EPA                 EPA
.*
.A5600   ANOP
.*
.*  CALL LINKAGE
.*
.ACALL   BALR  R14,R15                  CALL PUTLINE ROUTINE
.*
         AIF   ('&RSA' EQ '').A6900
         L     R14,&RSA                 RESTORE R14
.A6900   ANOP
.*
.AMEND   MEND
* ------------------------------------------------------------------- *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
&NAME    DS    0H
         ST    R9,SAV9HEX
         STM   R15,R1,HEXSAVE
         LA    R1,&FROM
         LA    R0,&LEN
         LA    R15,&TO
         BAL   R9,HEX
         LM    R15,R1,HEXSAVE
         L     R9,SAV9HEX
         MEND
* ------------------------------------------------------------------- *
         SPACE 1
         YREGS
         SPACE 1
SP000    EQU   0
         SPACE 1
FACEE    CSECT
FACEE    AMODE 31
FACEE    RMODE 24
* ------------------------------------------------------------------ *
*                  ADAPTED FROM DACEE TSO COMMAND.                   *
*                   THIS IS THE CALLABLE VERSION.                    *
* ------------------------------------------------------------------ *
         B     BEGINN-*(,R15)
         DC    AL1(16),CL16'FACEE   VER 1.2'
         DC    CL16' &SYSDATE &SYSTIME '
BEGINN   DS    0H
         BAKR  R14,0
*        STM   R14,R12,12(R13)
         LR    R12,R15
         LR    R7,R1                 SAVE POINTER TO ACEECSEC CSECT.
         USING FACEE,R12,R11         TWO BASE REGISTERS.
         LA    R11,4095(,R12)        LOAD SECOND BASE.
         LA    R11,1(,R11)
         USING ACEE,R7
         ST    R7,ACEEPNTR           GRAB POINTER TO ACEECSEC CSECT.
         L     R8,192(,R7)           GO GET ORIGINAL ACEE ADDRESS.
         ST    R8,REALACEE           AND PUT IT AWAY FOR DISPLAYING.
         GETMAIN RU,LV=DATALEN,SP=SP000,LOC=BELOW
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING DATAAREA,R13
         SPACE 1
INITCON  DS    0H
         MVI   LINE-1,X'40'          PRIME LINE-1 WITH A BLANK.
         MVC   LINE,LINE-1           BLANK ENTIRE AREA.
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* - - - - - -   DO THE VARIOUS FORMATTING TASKS   - - - - - - - - *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
DUMPACE  DS    0H
         BAL   R9,HEADERS            PRINT PROGRAM HEADER
         BAL   R9,ACEENAME           SHOW NAMED FIELDS IN THE ACEE
         BAL   R9,ACEEFLG            FORMAT CONTENTS OF ACEE FLAGS
         BAL   R9,ACEEDMP            HEX DUMP ACEE IN TWO FORMATS
         B     EOJ0                  NORMAL END
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
EOJ4     LA    R15,4                 SET CC = 4.
EOJ      DS    0H                    BYE.
         LR    R1,R13
         L     R13,4(,R13)
         ST    R15,16(,R13)          PUT RC INTO PASSED SAVE AREA
         L     R14,12(,R13)
         FREEMAIN RU,LV=DATALEN,A=(R1),SP=SP000
         LM    R0,R12,20(R13)
         PR
EOJ0     SR    R15,R15               SET CC = 0.
         B     EOJ                   CONT.
EOJ8     LA    R15,8                 SET CC = 8.
         B     EOJ                   CONT
         EJECT
FULLZERO DC    F'0'                  FIXED CONSTANT
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* - -           S  U  B  R  O  U  T  I  N  E  S               - - *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
FILLER0  DC    3F'0'                 Filler to resolve HEXTAB-240
HEX      DS    0H                    Print hex numbers in display form
         ST    R9,SAVER9F
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         L     R9,SAVER9F
         BR    R9                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
HEXSAVE  DS    3F                    Register save for HEX macro
SAV9HEX  DS    F
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEADERS  DS    0H                    Display program header
         ST    R9,SAVER9C
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+10(34),=C'SHOW AND DUMP CONTENTS OF THE ACEE'
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+10(34),DASHES
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+2(16),=C'ACEE ADDRESS:   '
*        HEX   LINE+20,4,ACEEPNTR    Don't use address of ACEE copy.
         HEX   LINE+20,4,REALACEE    Use only the passed ACEE address.
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+2(26),DASHES
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+2(42),FLAGL1
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+2(42),FLAGL2
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+2(26),DASHES
         APUT  LINE,62
         L     R9,SAVER9C
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ACEEFLG  DS    0H                    Display contents of ACEE flags
         ST    R9,SAVER9A
*
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(26),DASHES
         MVC   LINE+36(12),=C'(ACEE FLAGS)'
         APUT  LINE,55
*
* --                                      FLAG 1
         L     R4,ACEEPNTR
         MVC   FLFLG(1),X'26'(R4)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(7),=C'FLG1:  '
         HEX   LINE+12,1,FLFLG
         APUT  LINE,55
         LA    R3,FLG1TBL
         LA    R6,8
         BAL   R9,FLGLOOP
* --                                      FLAG 2
         L     R4,ACEEPNTR
         MVC   FLFLG(1),X'27'(R4)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(7),=C'FLG2:  '
         HEX   LINE+12,1,FLFLG
         APUT  LINE,55
         LA    R3,FLG2TBL
         LA    R6,8
         BAL   R9,FLGLOOP
* --                                      FLAG 3
         L     R4,ACEEPNTR
         MVC   FLFLG(1),X'28'(R4)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(7),=C'FLG3:  '
         HEX   LINE+12,1,FLFLG
         APUT  LINE,55
         LA    R3,FLG3TBL
         LA    R6,8
         BAL   R9,FLGLOOP
* --                                      FLAG 4
         L     R4,ACEEPNTR
         MVC   FLFLG(2),X'38'(R4)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(7),=C'FLG4:  '
         HEX   LINE+12,2,FLFLG
         APUT  LINE,55
         LA    R3,FLG4TBL
         LA    R6,8
         BAL   R9,FLGLOOP
* --                                      FLAG 5
         L     R4,ACEEPNTR
         MVC   FLFLG(1),X'85'(R4)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(7),=C'FLG5:  '
         HEX   LINE+12,1,FLFLG
         APUT  LINE,55
         LA    R3,FLG5TBL
         LA    R6,8
         BAL   R9,FLGLOOP
* --                                      FLAG 6
         L     R4,ACEEPNTR
         MVC   FLFLG(2),X'86'(R4)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(7),=C'FLG6:  '
         HEX   LINE+12,2,FLFLG
         APUT  LINE,55
         LA    R3,FLG6TBL
         LA    R6,8
         BAL   R9,FLGLOOP
* --
         L     R9,SAVER9A
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
FLGLOOP  DS    0H                    Go thru flag table for each flag
         ST    R9,SAVER9D
         MVC   TSFLG(1),0(R3)
         XR    R2,R2
         IC    R2,TSFLG
         EX    R2,TMFLG
         BNO   PRTSND
PRTFST   DS    0H
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         HEX   LINE+3,1,TSFLG
         MVC   LINE+8(8),3(R3)
         MVC   LINE+20(10),11(R3)
         APUT  LINE,55
         B     FLGLBCK
PRTSND   DS    0H
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         HEX   LINE+3,1,TSFLG
         MVC   LINE+8(8),3(R3)
         MVC   LINE+20(10),21(R3)
         APUT  LINE,55
         B     FLGLBCK
FLGLBCK  DS    0H
         LA    R3,31(,R3)
         BCT   R6,FLGLOOP
FLGLEND  DS    0H
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(26),DASHES
         APUT  LINE,55
         L     R9,SAVER9D
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
TMFLG    TM    FLFLG,X'00'           Contents of these are modified
TSFLG    DC    X'00'
FLFLG    DC    X'0000'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ACEENAME DS    0H                    Display name fields in the ACEE
         ST    R9,SAVER9E
         L     R7,ACEEPNTR
         USING ACEEACEE,R7
*
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1                     Userid
         MVC   LINE+2(L'USRIDMS),USRIDMS
         MVC   LINE+20(8),X'15'(R7)
         HEX   LINE+40,1,X'14'(R7)
         MVI   LINE+40,X'40'
         APUT  LINE,55
*
         MVC   LINE,LINE-1                     Group ID
         MVC   LINE+2(L'GRPIDMS),GRPIDMS
         MVC   LINE+20(8),X'1E'(R7)
         HEX   LINE+40,1,X'1D'(R7)
         MVI   LINE+40,X'40'
         APUT  LINE,55
*
         MVC   LINE,LINE-1                     Proc ID for STC
         MVC   LINE+2(L'PRCIDMS),PRCIDMS
         MVC   LINE+20(8),ACEEPROC
         APUT  LINE,55
*
         MVC   LINE,LINE-1                     Terminal ID
         MVC   LINE+2(L'TRMIDMS),TRMIDMS
         MVC   LINE+20(8),X'40'(R7)
         APUT  LINE,55
*
         MVC   LINE,LINE-1
         MVC   LINE+2(L'SURIDMS),SURIDMS       Surrogate Userid
         CLC   =X'0000',X'90'(R7)
         BE    NOSURMVE
         MVC   LINE+20(8),X'90'(R7)
NOSURMVE DS    0H
         APUT  LINE,55
*
         L     R9,SAVER9E
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ACEEDMP  DS    0H           Dump contents in HEX and ISPF 3-line format
         ST    R9,SAVER9B
*
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+7(15),=C'(ACEE CONTENTS)'
         APUT  LINE,55
         MVC   LINE,LINE-1
         MVC   LINE+2(26),DASHES
         APUT  LINE,55
         L     R7,ACEEPNTR
         ST    R7,SAVER7A
         LA    R6,12
         LA    R5,0
         STCM  R5,3,STORCNT
LINELUP  DS    0H
         L     R7,SAVER7A
         MVC   DMPADDR(16),0(R7)
         MVI   LINE-1,X'40'
         MVC   LINE,LINE-1
         MVC   LINE+2(5),=C'ACEE '
         HEX   LINE+8,2,STORCNT
         MVI   LINE+7,C'+'
         HEX   LINE+17,4,DMPADDR
         HEX   LINE+27,4,DMPADDR+4
         HEX   LINE+37,4,DMPADDR+8
         HEX   LINE+47,4,DMPADDR+12
         APUT  LINE,62
* --- >
         MVC   DMPWORK,DMPADDR
         TR    DMPWORK(16),TRTBL0
         MVC   LINE,LINE-1
         MVC   LINE+17(16),DMPWORK
         APUT  LINE,62
         MVC   DMPWORK,DMPADDR
         TR    DMPWORK(16),TRTBL1
         MVC   LINE,LINE-1
         MVC   LINE+17(16),DMPWORK
         APUT  LINE,62
         MVC   DMPWORK,DMPADDR
         TR    DMPWORK(16),TRTBL2
         MVC   LINE,LINE-1
         MVC   LINE+17(16),DMPWORK
         APUT  LINE,62
         MVC   LINE,LINE-1
         MVC   LINE+17(38),DASHES
         APUT  LINE,62
* --- >
         LA    R7,16(,R7)
         LA    R5,16(,R5)
         STCM  R5,3,STORCNT
         ST    R7,SAVER7A
         BCT   R6,LINELUP
         L     R9,SAVER9B
         BR    R9
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         SPACE
USRIDMS  DC    C'ACEE USERID    :             LENGTH:     '
GRPIDMS  DC    C'ACEE GROUP ID  :             LENGTH:     '
PRCIDMS  DC    C'ACEE PROCEDURE :                         '
TRMIDMS  DC    C'ACEE TERMINAL  :                         '
SURIDMS  DC    C'ACEE SURROGATE :                         '
BLANKS   DC    C'        '         8 BLANKS
DASHES   DC    C'--------------------------------------------'
FLAGL1   DC    C'FLAG 1 - +26     FLAG2 - +27   FLAG3 - +28'
FLAGL2   DC    C'FLAG 4 - +38(2)  FLAG5 - +85   FLAG6 - +86'
NOID     DC    X'0000000000000000'
FLAG2    DS    X
FLAG2ON  EQU   B'10000000'             TURN ON
FLAG2OFF EQU   B'01000000'             TURN OFF
TRTBL0   DS    0D
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'404040404040404040404A4B4C4D4E4F'
         DC    XL16'504040404040404040405A5B5C5D5E5F'
         DC    XL16'606140404040404040406A6B6C6D6E6F'
         DC    XL16'404040404040404040407A7B7C7D7E7F'
         DC    XL16'40818283848586878889404040404040'
         DC    XL16'40919293949596979899404040404040'
         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'
         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'
         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'
TRTBL1   DS    0D
         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'
         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'
         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'
         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'
         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'
         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'
         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'
         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'
         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'
         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'
         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'
         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'
         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'
         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'
         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'
         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'
TRTBL2   DS    0D
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
         LTORG
CPPLPTR  DC    F'0'
FLG1TBL  DS    0F
         DC    X'80',C'  ACEESPEC',C'SPECIAL   ',C'NOSPECIAL '
         DC    X'40',C'  ACEEADSP',C'ADSP      ',C'NOADSP    '
         DC    X'20',C'  ACEEOPER',C'OPERATIONS',C'NOOPERATNS'
         DC    X'10',C'  ACEEAUDT',C'AUDITOR   ',C'NOAUDITOR '
         DC    X'08',C'  ACEELOGU',C'RACFLOG   ',C'NORACFLOG '
         DC    X'04',C'  RESERVED',C'HEX04     ',C'NOHEX04   '
         DC    X'02',C'  ACEEPRIV',C'PRIV      ',C'NOPRIV    '
         DC    X'01',C'  ACEERACF',C'RACFDEFUSR',C'NORACFDEFU'
         SPACE 3
FLG2TBL  DS    0F
         DC    X'80',C'  ACEEALTR',C'DEFALTR   ',C'NODEFALTR '
         DC    X'40',C'  ACEECNTL',C'DEFCNTL   ',C'NODEFCNTL '
         DC    X'20',C'  ACEEUPDT',C'DEFUPDT   ',C'NODEFUPDT '
         DC    X'10',C'  ACEEREAD',C'DEFREAD   ',C'NODEFREAD '
         DC    X'08',C'  RESERVED',C'HEX08     ',C'NOHEX08   '
         DC    X'04',C'  RESERVED',C'HEX04     ',C'NOHEX04   '
         DC    X'02',C'  RESERVED',C'HEX02     ',C'NOHEX02   '
         DC    X'01',C'  ACEENONE',C'DEFNOAUTH ',C'NODEFNOAUT'
         SPACE 3
FLG3TBL  DS    0F
         DC    X'80',C'  ACEEGRPA',C'GROUP+UID ',C'ONLYUID   '
         DC    X'40',C'  ACEERASP',C'RACFADRSPC',C'NOTRACFADR'
         DC    X'20',C'  ACEECLNT',C'UNAUTHCLNT',C'          '
         DC    X'10',C'  ACEEACLT',C'AUTHCLIENT',C'          '
         DC    X'08',C'  ACEETSKP',C'TASKLVL   ',C'NOTASKLVL '
         DC    X'04',C'  ACEEIUSP',C'INITUSP   ',C'NOINITUSP '
         DC    X'02',C'  ACEEDUID',C'DEFAULTUID',C'NODEFLTUID'
         DC    X'01',C'  ACEENPWR',C'NOPSWDREQ ',C'PSWDREQ   '
         SPACE 3
FLG4TBL  DS    0F
         DC    X'80',C'  RESERVED',C'HEX80     ',C'NOHEX80   '
         DC    X'40',C'  RESERVED',C'HEX40     ',C'NOHEX40   '
         DC    X'20',C'  ACEEUATH',C'DEFUSERS  ',C'NODEFUSERS'
         DC    X'10',C'  RESERVED',C'HEX10     ',C'NOHEX10   '
         DC    X'08',C'  ACEEDASD',C'PROTDASD  ',C'NOPROTDASD'
         DC    X'04',C'  ACEETAPE',C'PROTTAPE  ',C'NOPROTTAPE'
         DC    X'02',C'  ACEETERM',C'PROTTERM  ',C'NOPROTTERM'
         DC    X'01',C'  RESERVED',C'HEX01     ',C'NOHEX01   '
         SPACE 3
FLG5TBL  DS    0F
         DC    X'80',C'  ACEEMODE',C'ACEEAMOD31',C'ACEEAMOD24'
         DC    X'40',C'  ACEEVMSK',C'PLCL1024  ',C'PLCL128   '
         DC    X'20',C'  ACEED4OK',C'DAT4USED  ',C'DAT4NOTUSD'
         DC    X'10',C'  ACEEXNVR',C'ENVROBJOTH',C'ENVROBJHER'
         DC    X'08',C'  ACEESTOK',C'SERVAUTH  ',C'NOSERVAUTH'
         DC    X'04',C'  ACEENSTE',C'ENVNSTFSTA',C'NOENVNSTAF'
         DC    X'02',C'  ACEEDALY',C'DAILYLOGON',C'NODALYLOGN'
         DC    X'01',C'  RESERVED',C'HEX01     ',C'NOHEX01   '
         SPACE 3
FLG6TBL  DS    0F
         DC    X'80',C'  ACEERAUI',C'RESTACCUID',C'NORESTACCU'
         DC    X'40',C'  ACEERUAA',C'RESTACUXOT',C'NORESACUXO'
         DC    X'20',C'  ACEERUAV',C'CHKDOTHER ',C'NOCHKOTHER'
         DC    X'10',C'  RESERVED',C'HEX10     ',C'NOHEX10   '
         DC    X'08',C'  RESERVED',C'HEX08     ',C'NOHEX08   '
         DC    X'04',C'  RESERVED',C'HEX04     ',C'NOHEX04   '
         DC    X'02',C'  RESERVED',C'HEX02     ',C'NOHEX02   '
         DC    X'01',C'  RESERVED',C'HEX01     ',C'NOHEX01   '
         SPACE 3
ACEEPNTR DS    F
REALACEE DS    F
DATAAREA DSECT
SAVE     DS    9D
SAVACEE  DS    F
SAVER7A  DS    F
SAVER3C  DS    F
SAVER3D  DS    F
SAVER9A  DS    F
SAVER9B  DS    F
SAVER9C  DS    F
SAVER9D  DS    F
SAVER9E  DS    F
SAVER9F  DS    F
CMBUFAD  DS    F                   COMMAND BUFFER ADDRESS
DMPADDR  DS    XL16
DMPWORK  DS    XL16
STORCNT  DS    XL2
NEWIDL   DS    XL1
NEWID    DC    C'        '         STORE NEW USERID HERE
         DC    C' '
LINE     DS    CL133
         DS    CL72
         SPACE 1
DATALEN  EQU   *-DATAAREA          LENGTH OF DATA AREA
         IHAACEE
         END
